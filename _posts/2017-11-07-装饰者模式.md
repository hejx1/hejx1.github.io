---
layout: post
title: 装饰者模式
date: 2017-11-07
tags: 设计模式
---

## 装饰者模式

我们即将再度探讨典型的继承滥用问题。你将在本文学到如何使
用对象组合的方式，做到在运行时装饰类。为什么呢？一旦你熟悉了装饰的
技巧，你将能够在不修改任何底层代码的情况下,给你的（或别人的）对象赋
予新的职责。

动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

### 认识装饰者模式

我们已经了解利用继承无法完全解决问题，在星巴兹遇到的问
题有：类数量爆炸、设计死板，以及基类加入的新功能并不适用于所
有的子类。
所以，在这里要采用不一样的做法：我们要以饮料为主体，然后在运
行时以调料来“装饰”（decorate）饮料。比方说，如果顾客想要摩卡
和奶泡深焙咖啡，那么，要做的是：

- 拿一个深焙咖啡（DarkRoast）对象
- 以摩卡（Mocha）对象装饰它
- 以奶泡（Whip）对象装饰它
- 调用cost()方法，并依赖委托（delegate）将调料的价钱加上去。

好了！但是如何“装饰”一个对象，而“委托”又要如何与此搭配使
用呢？给一个暗示：把装饰者对象当成“包装者”。让我们看看这是
如何工作的...... 



装饰者和被装饰对象有相同的超类型。

- 你可以用一个或多个装饰者包装一个对象。
- 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它。
- **装饰者可以在所委托被装饰者的行为之前 (与/或) 之后，加上自己的行为，以达到特定的目的。**
- 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。

### 以装饰者模式构造饮料订单

#### Beverage

Beverage（饮料）是一个抽象类，店内所提供的饮料都必须继承自此类。

```
package hejx.demo.starbuzz;

/**
 * Created by 追风少年
 * Beverage（饮料）是一个抽象类，店内所提供的饮料都必须继承自此类。
 * Beverage是一个抽象类，有两个方法：getDescription()及cost()。
 * @email doubihah@foxmail.com
 * @create 2017/11/7 11:47
 **/
public abstract class Beverage {

    protected String description = "Unknown Beverage";

    protected int cupSize = Beverage.TALL;

    /**
     * 大杯
     */
    public static final int TALL = 1;

    /**
     * 超大杯
     */
    public static final int GRANDE = 2;

    /**
     * 超超大杯
     */
    public static final int VENTI = 3;

    /**
     * 设置杯量
     * @param cupSize
     */
    public void setCupSize(int cupSize){
        this.cupSize = cupSize;
    }

    public int getCupSize() {
        return cupSize;
    }

    /**
     * getDescription()已经在此实现了，但是cost()必须在子类中实现。
     * @return
     */
    public String getDescription() {
        return description;
    }

    /**
     * 计算价钱
     * @return
     */
    public abstract double cost();

}


```
#### CondimentDecorator

Condiment（调料） 抽象类，也就是装饰者类吧
```
package hejx.demo.starbuzz.condiment;

import hejx.demo.starbuzz.Beverage;

/**
 * Created by 追风少年
 * Condiment（调料） 抽象类，也就是装饰者类吧
 * @email doubihah@foxmail.com
 * @create 2017/11/7 12:05
 **/
public abstract class CondimentDecorator extends Beverage{
    /**
     * 饮料变量
     */
    protected Beverage beverage;

    @Override
    public int getCupSize() {
        return beverage.getCupSize();
    }
    public abstract String getDescription();
}

```
### 实现饮料

#### Espresso

先从浓缩咖啡（Espresso）开始。别忘了，我们需要为具体的饮料设置描述，而且还必须实现cost()方法。
```
package hejx.demo.starbuzz.drink;

import hejx.demo.starbuzz.Beverage;

/**
 * Created by 追风少年
 * 浓咖啡
 * 让Espresso扩展自 Beverage类，因为Espresso是一种饮料。
 * @email doubihah@foxmail.com
 * @create 2017/11/7 12:07
 **/
public class Espresso extends Beverage{

    /**
     * 为了要设置饮料的描述，我们写了一个构造器。记住，description实例变量继承自 Beverage。
     */
    public Espresso() {
        description = "Espresso";
    }

    /**
     * 最后，需要计算Espresso的价钱，现在不需要管调料的价钱，直接把Espresso的价格$1.99返回即可。
     */
    @Override
    public double cost() {
        return 1.99;
    }

}

```
### 实现调料装饰

#### Mocha

摩卡 Mocha
```
package hejx.demo.starbuzz.condiment;

import hejx.demo.starbuzz.Beverage;

/**
 * Created by 追风少年
 * 摩卡是一个装饰者，所以让它扩展自CondimentDecorator。
 * 要让Mocha能够引用一个Beverage，做法如下：
     (1)用一个实例变量记录饮料，也就是被装饰者。
     (2)想办法让被装饰者（饮料）被记录到实例变量中。这里的做法是：把
     饮料当作构造器的参数，再由构造器将此饮料记录在实例变量中。
 * @email doubihah@foxmail.com
 * @create 2017/11/7 12:14
 **/
public class Mocha extends CondimentDecorator {

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Mocha";
    }

    /**
     * 要计算带Mocha饮料的价钱。
     * 首先把调用委托给被装饰对象，以计算价钱，然后再加上Mocha的价钱，得到最后结果。
     */
    @Override
    public double cost() {
        double cost = beverage.cost();
        if(getCupSize() == Beverage.TALL){
            cost += 0.10;
        }else if(getCupSize() == Beverage.GRANDE){
            cost += 0.15;
        }else if(getCupSize() == Beverage.VENTI){
            cost += 0.20;
        }
        System.out.println("Mocha $ " + cost);
        return cost;
    }

}


```
#### Whip

奶泡 Whip
```
package hejx.demo.starbuzz.condiment;

import hejx.demo.starbuzz.Beverage;

/**
 * Created by 追风少年
 * 奶泡
 * @email doubihah@foxmail.com
 * @create 2017/11/7 12:19
 **/
public class Whip extends CondimentDecorator {

    public Whip(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", Whip";
    }

    @Override
    public double cost() {
        System.out.println("Whip $ 0.16");
        /**
         * 要计算带Whip饮料的价钱。
         * 首先把调用委托给被装饰对象，以计算价钱，然后再加上Whip的价钱，得到最后结果。
         */
        return beverage.cost() + .16;
    }

}


```
### 供应咖啡

恭喜你，是时候舒服地坐下来，点一些咖啡，看看你利用装饰者模式设计出的灵活系统是多么神奇了。
## 这是用来下订单的一些测试代码

```
package hejx.demo.starbuzz;

import hejx.demo.starbuzz.condiment.Mocha;
import hejx.demo.starbuzz.condiment.Whip;
import hejx.demo.starbuzz.drink.DarkRoast;
import hejx.demo.starbuzz.drink.Espresso;

/**
 * Created by 追风少年
 * 这是用来下订单的一些测试代码
 * @email doubihah@foxmail.com
 * @create 2017/11/7 12:21
 **/
public class StarbuzzCoffee {

    public static void main(String[] args) {
        // 先来一杯浓咖啡,不需要调料,打印它的描述和价钱
        Beverage beverage = new Espresso();
        System.out.println(beverage.getDescription() + " $" + beverage.cost());
        System.out.println("===========================");
        // 再来一杯焦炒（深色）咖啡
        Beverage beverage2 = new DarkRoast();
        beverage2.setCupSize(Beverage.TALL);
        beverage2 = new Mocha(beverage2); // 加一点摩卡
        beverage2 = new Mocha(beverage2); // 再加一点摩卡
        beverage2 = new Whip(beverage2); // 还来点奶泡
        System.out.println(beverage2.getDescription() + " $" + beverage2.cost());

    }

}
```