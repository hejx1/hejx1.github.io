---
layout: post
title: mysql 留存用户统计
date: 2017-12-05
tags: mysql    
---

### 需求

统计用户的留存率，用户留存率可以得知用户的忠诚度的多少。

留存率：从用户开始使用应用，经过一段时间后仍然继续使用应用的用户，被认为是留存用户；这部分用户占当时新增用户的比例则为留存率

本次需要统计次日、7日、30日留存率

### 实现方案

建立留存率表，每天凌晨使用存储过程更新此表。

已知元素:

- login_info: 登录日志表
- login_info.create_time:用户的注册时间
- login_info.login_time:用户的登陆时间

### 1. 创建留存统计表

```
DROP TABLE IF EXISTS `remain_info`;
CREATE TABLE `remain_info` (
  `date` datetime NOT NULL COMMENT '日期',
  `add_num` int(11) DEFAULT NULL COMMENT '新增玩家',
  `second_day` float NOT NULL DEFAULT '0' COMMENT '次日留存',
  `seventh_day` float NOT NULL DEFAULT '0' COMMENT '7日留存率',
  `thirtieth_day` float NOT NULL DEFAULT '0' COMMENT '30日留存率',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

### 2. 创建相关存储过程

insert_remainData:用于处理历史数据

```
DROP PROCEDURE IF EXISTS `insert_remainData`;
DELIMITER ;;
CREATE DEFINER=`root`@`%` PROCEDURE `insert_remainData`(IN `beginDate` date,IN `endDate` date)
    COMMENT '生产beginDate~endDate时间段的留存数据'
BEGIN  
  
DECLARE nowdate date DEFAULT NOW();  
DECLARE endtmp date DEFAULT NOW();  
set nowdate = DATE_FORMAT(beginDate,'%Y%m%d');  
set endtmp = DATE_FORMAT(endDate,'%Y%m%d');  
WHILE nowdate<=endtmp   
DO  
CALL save_remain_data_by_date(nowdate);
set nowdate = DATE_ADD(nowdate,INTERVAL 1 DAY);  
END WHILE;  
  
END
;;
DELIMITER ;
```

save_remain_data:定时执行的存储过程,处理昨天的留存率数据

```
DROP PROCEDURE IF EXISTS `save_remain_data`;
DELIMITER ;;
CREATE DEFINER=`root`@`%` PROCEDURE `save_remain_data`()
BEGIN 

DECLARE today DATE DEFAULT CURDATE();  
DECLARE yesterday DATE DEFAULT DATE_SUB(today, INTERVAL 1 DAY);  
DECLARE days_ago_2 DATE DEFAULT DATE_SUB(today, INTERVAL 2 DAY);  
DECLARE days_ago_6 DATE DEFAULT DATE_SUB(today, INTERVAL 6 DAY);  
DECLARE days_ago_7 DATE DEFAULT DATE_SUB(today, INTERVAL 7 DAY);  
DECLARE days_ago_29 DATE DEFAULT DATE_SUB(today, INTERVAL 29 DAY);  
DECLARE days_ago_30 DATE DEFAULT DATE_SUB(today, INTERVAL 30 DAY);  

-- 统计昨天一天的注册人数  
INSERT INTO remain_info(add_num, date, create_time) 
SELECT COUNT(DISTINCT role_uid) , DATE_SUB(CURDATE(), INTERVAL 1 DAY), NOW() 
FROM login_info WHERE create_time BETWEEN DATE_SUB(CURDATE(), INTERVAL 1 DAY) AND CURDATE();
-- 修改前天的2日留存率 
UPDATE remain_info SET second_day = FORMAT((  
   (SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_2 AND yesterday) AND (login_time BETWEEN yesterday AND today))  
/   
(SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_2 AND yesterday))   
),2),update_time=today WHERE date = days_ago_2;  
-- 7日留存率  
UPDATE remain_info SET seventh_day = FORMAT(( 
SELECT(  
   (SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_7 AND days_ago_6) AND (login_time BETWEEN yesterday AND today))  
/   
(SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_7 AND days_ago_6))  
)  
),2),update_time=today WHERE date = days_ago_7;  
-- 30日留存率  
UPDATE remain_info SET thirtieth_day = FORMAT((  
SELECT(  
   (SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_30 AND days_ago_29) AND (login_time BETWEEN yesterday AND today))  
/   
(SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_30 AND days_ago_29))  
)  
),2),update_time=today WHERE date = days_ago_30;  
END
;;
DELIMITER ;
```

save_remain_data_by_date:根据目标日期处理留存率

```
DROP PROCEDURE IF EXISTS `save_remain_data_by_date`;
DELIMITER ;;
CREATE DEFINER=`root`@`%` PROCEDURE `save_remain_data_by_date`(IN `today` date)
BEGIN 

DECLARE yesterday DATE DEFAULT DATE_SUB(today, INTERVAL 1 DAY);  
DECLARE days_ago_2 DATE DEFAULT DATE_SUB(today, INTERVAL 2 DAY);  
DECLARE days_ago_6 DATE DEFAULT DATE_SUB(today, INTERVAL 6 DAY);  
DECLARE days_ago_7 DATE DEFAULT DATE_SUB(today, INTERVAL 7 DAY);  
DECLARE days_ago_29 DATE DEFAULT DATE_SUB(today, INTERVAL 29 DAY);  
DECLARE days_ago_30 DATE DEFAULT DATE_SUB(today, INTERVAL 30 DAY);  

-- 统计昨天一天的注册人数
INSERT INTO remain_info(add_num, date, create_time) 
SELECT COUNT(DISTINCT role_uid) , DATE_SUB(today, INTERVAL 1 DAY), NOW() 
FROM login_info WHERE create_time BETWEEN DATE_SUB(today, INTERVAL 1 DAY) AND today;
-- 修改前天的2日留存率  
UPDATE remain_info SET second_day = FORMAT((  
   (SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_2 AND yesterday) AND (login_time BETWEEN yesterday AND today))  
/   
(SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_2 AND yesterday))   
),2),update_time=today WHERE date = days_ago_2;  
-- 7日留存率  
UPDATE remain_info SET seventh_day = FORMAT(( 
SELECT(  
   (SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_7 AND days_ago_6) AND (login_time BETWEEN yesterday AND today))  
/   
(SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_7 AND days_ago_6))  
)  
),2),update_time=today WHERE date = days_ago_7;  
-- 30日留存率  
UPDATE remain_info SET thirtieth_day = FORMAT((  
SELECT(  
   (SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_30 AND days_ago_29) AND (login_time BETWEEN yesterday AND today))  
/   
(SELECT COUNT(DISTINCT role_uid) FROM login_info WHERE (create_time BETWEEN days_ago_30 AND days_ago_29))  
)  
),2),update_time=today WHERE date = days_ago_30;  
END
;;
DELIMITER ;
```

### 3. 创建事件（event）

```
drop event if EXISTS upload_remain;
# 创建计划任务，设置第一次的执行时间为'2017-12-06 01:00:00',并且每天执行一次
create event upload_remain   
on schedule every 1 day starts timestamp '2017-12-06 01:00:00'  
do CALL save_remain_data;
SET GLOBAL event_scheduler = 1;  -- 开启定时器
ALTER EVENT upload_remain ON COMPLETION PRESERVE ENABLE;   -- 开启事件
```

### 需求奖励

mysql 存储过程+1;

mysql 事件使用+1;