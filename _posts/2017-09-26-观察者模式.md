---
layout: post
title: 观察者模式
date: 2017-11-07
tags: 设计模式
---

## 观察者模式

有一个模式可以帮你的对象知悉现况，不会错过该对象感兴趣的事。对象甚至在运行时可决定是否要继续被通知。观察者模式是JDK中使用最多的模式之一，非常有用。我们也会一并介绍一对多关系，以及松耦合（对，没错,我们说耦合）。有了观察者，你将会消息灵通。

### 认识观察者模式

我们看看报纸和杂志的订阅是怎么回事：

- 报社的业务就是出版报纸。
- 向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。
- 当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。
- 只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。

出版者 + 订阅者 = 观察者模式

如果你了解报纸的订阅是怎么回事，其实就知道观察者模式是怎么回
事，只是名称不太一样：出版者改称为“主题”（Subject），订阅者改称
为“观察者”（Observer）。

### 定义观察者模式

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

主题和观察者定义了一对多的关系。观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知。根据通知的风格，观察者可能因此新值而更新。稍后你会看到，实现观察者模式的方法不只一种，但是以包含Subject与Observer接口的类设计的做法最常见。



## 例子: Internet气象观测站

### 需求

恭喜贵公司获选为敝公司建立下一代Internet气象观测站！该气象站必须建立在我们专利申请中的WeatherData对象上，由WeatherData对象负责追踪目前的天气状况（温度、湿度、气压）。

**我们希望贵公司能建立一个应用，有三种布告板，分别显示目前的状况、气象统计及简单的预报。当WeatherObject对象获得最新的测量数据时，三种布告板必须实时更新。而且，这是一个可以扩展的气象站，Weather-O-Rama气象站希望公布一组API，好让其他开发人员可以写出自己的气象布告板，并插入此应用中。我们希望贵公司能提供这样的API。**

瞧一瞧刚送到的**WeatherData**类

- getTemperature()
- getHumidity()
- getPressure()
- mentsChanged()

WeatherObject的开发人员留了一个线索

```
/*
 * 一旦气象测量更新，此方法会被调用
 */
public void measurementsChanged() {
    // 你的代码加在这里
}
```
### 实现需求

Java为观察者模式提供了内置的支持，但是，我们暂时不用它，而是先自己动手。虽然，某些时候可以利用Java内置的支持，但是有许多时候，自己建立这一切会更具弹性（况且建立这一切并不是很麻烦）。所以，让我们从建立接口开始吧。

### 主题接口 Subject

```
/**
 * Created by 追风少年
 * 这是主题接口,对象使用此接口注册为观察者,或者把自己从观察者中删除
 * @email doubihah@foxmail.com
 * @create 2017-09-26 16:26
 **/
public interface Subject {

    /**
     * 注册观察者
     * @param observer 观察者
     */
    void registerObserver(Observer observer);

    /**
     * 移除观察者
     * @param observer 观察者
     */
    void removeObserver(Observer observer);

    /**
     * 主题改变时通知所有观察者
     */
    void notifyObservers();
    
    /**
     * 需要通知观察者
     */
    void setChanged();

    /**
     * clear changed to false
     */
    void clearChanged();

}
```
### 观察者接口 Observer

```
/**
 * Created by 追风少年
 * 观察者接口
 * 所有潜在的观察者必须实现观察者接口,这个接口只有update()一个方法
 * 当主题状态改变时它被调用
 * @email doubihah@foxmail.com
 * @create 2017-09-26 16:32
 **/
public interface Observer {

    void update(float temp, float humidity, float pressure);

}
```
### 展示板接口 DisplayElement
```
/**
 * Created by 追风少年
 * 展示板接口
 * @email doubihah@foxmail.com
 * @create 2017-09-26 17:15
 **/
public interface DisplayElement {

    void display();

} 
```
### 在WeatherData中实现主题接口

```
/**
 * Created by 追风少年
 *
 * @email doubihah@foxmail.com
 * @create 2017-09-26 16:14
 **/
public class WeacherData extends Subject {

    /**
     * 我们加上一个ArrayList来纪录观察者，此ArrayList是在构造器中建立的。
     */
    private ArrayList observers;
    private float temperature;
    private float humidity;
    private float pressure;

    public WeacherData() {
        observers = new ArrayList();
    }
    
    /**
     * setChanged() 方法用来标记状态已经改变的事实，好让notifyObservers()知道当它被调
     用时应该更新观察者。如果调用notifyObservers()之前没有先调用setChanged()，观察者
     就“不会”被通知。
     */
    @Override
    public void setChanged() {
        changed = true;
    }

    @Override
    public void clearChanged() {
        changed = false;
    }

    /**
     * 当注册观察者时，我们只要把它加到ArrayList的后面即可。
     * @param observer 观察者
     */
    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    /**
     * 同样地，当观察者想取消注册，我们把它从ArrayList中删除即可。
     * @param observer 观察者
     */
    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    /**
     * 有趣的地方来了！在这里，我们把状态告诉每一个观察者。因为观察者都实现了update()，所以我们知道如何通知它们。
     */
    @Override
    public void notifyObservers() {
        if(!changed) return ;
        for (int i = 0; i < observers.size(); i++) {
            Observer observer = (Observer)observers.get(i);
            observer.update(temperature, humidity, pressure);
        }
        clearChanged();
    }

    /**
     * 当从气象站得到更新观测值时,通知观察者
     */
    private void measurementsChanged(){
        setChanged();
        notifyObservers();
    }

    /**
     * 我们想要每本书随书赠送一个小型气象站，但是出版社不肯。
     * 所以，和从装置中读取实际的气象数据相比，我们宁愿利用这个方法来测试布告板。
     * 或者，为了好玩，你也可以写代码从网站上抓取观测值。
     * @param temperature
     * @param humidity
     * @param pressure
     */
    public void setMeasurements(float temperature, float humidity, float pressure){
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        this.measurementsChanged();
    }

    //... WeatherData的其他方法
}
```
### 现在，我们来建立布告板

```
public class CurrentConditionsDisplay implements Observer, DisplayElement {
    private float temperature;
    private float humidity;
    private Subject weatherData;
    public CurrentConditionsDisplay(Subject weatherData) {
        this.weatherData = weatherData;
        weatherData.registerObserver(this);
    }
    
    /**
     * 当update()被调用时，我们把温度和湿度保存起来，然后调用display()。
     * @param temperature 温度
     * @param humidity 湿度
     * @param pressure 气压
     */
    public void update(float temperature, float humidity, float pressure) {
        this.temperature = temperature;
        this.humidity = humidity;
        display();
    }
    public void display() {
        System.out.println("Current conditions: " + temperature 
            + "F degrees and " + humidity + "% humidity");
    }
}
```
## 启动气象站

```
public class WeatherStation {

    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentDisplay = 
            new CurrentConditionsDisplay(weatherData);
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);
        ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData);
        weatherData.setMeasurements(80, 65, 30.4f);
        weatherData.setMeasurements(82, 70, 29.2f);
        weatherData.setMeasurements(78, 90, 29.2f);
    }

}
```
## 使用Java内置的观察者模式

到目前为止，我们已经从无到有地完成了观察者模式，但是，Java API有内置的观察者模式。java.util包（package）内包含最基本的Observer接口与Observable类，这和我们的Subject接口与Observer接口很相似。Observer接口与Observable类使用上更方便，因为许多功能都已经事先准备好了。你甚至可以使用推（push）或拉（pull）的方式传送数据，稍后就会看到这样的例子。为了更了解java.uitl.Observer和java.util.Observable，看看下面的图，这是修改后的气象站OO设计。

### 利用内置的支持重做气象站

```
import java.util.Observable;

/**
 * Created by 追风少年
 *
 * @email doubihah@foxmail.com
 * @create 2017-09-26 16:14
 **/
public class WeacherData extends Observable{

    private float temperature;
    private float humidity;
    private float pressure;

    public WeacherData() {}

    /**
     * 当从气象站得到更新观测值时,通知观察者
     */
    private void measurementsChanged(){
        /**
         * setChanged() 方法用来标记状态已经改变的事实，好让notifyObservers()知道当它被调
         用时应该更新观察者。如果调用notifyObservers()之前没有先调用setChanged()，观察者
         就“不会”被通知。
         * setChanged() 方法可以让你在更新观察者时，有更多的弹性，你可以更
             适当地通知观察者。比方说，如果没有setChanged()方法，我们的气象站测量是如此敏锐，
             以致于温度计读数每十分之一度就会更新，这会造成WeatherData对象持续不断地通知观察
             者，我们并不希望看到这样的事情发生。如果我们希望半度以上才更新，就可以在温度差
             距到达半度时，调用setChanged()，进行有效的更新。
         */
        super.setChanged();
        notifyObservers(); // 通知观察者的时候没有传递变量,这里采用的是"拉"的做法不是推
    }

    public void setMeasurements(float temperature, float humidity, float pressure){
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        this.measurementsChanged();
    }

    public float getTemperature() {
        return temperature;
    }

    public float getHumidity() {
        return humidity;
    }

    public float getPressure() {
        return pressure;
    }
}
```

```
import java.util.Observable;
import java.util.Observer;

/**
 * Created by 追风少年
 * 布告板
 * @email doubihah@foxmail.com
 * @create 2017-09-26 17:36
 **/
public class CurrentConditionsDisplay implements Observer,DisplayElement {

    private float temperature;
    private float humidity;
    private Observable observable;

    public CurrentConditionsDisplay(Observable weacherData) {
        this.observable = weacherData;
        this.observable.addObserver(this);
    }

    @Override
    public void display() {
        System.out.println("CurrentConditionsDisplay: " +
                "temperature=" + temperature + ",humidity=" + humidity);
    }

    @Override
    public void update(Observable obs, Object arg) {
        if(obs instanceof WeacherData){
            WeacherData weacherData = (WeacherData) obs;
            this.temperature = weacherData.getTemperature();
            this.humidity = weacherData.getHumidity();
            display();
        }
    }
}
```
## java.util.Observable的黑暗面

是的，你注意到了！如同你所发现的，可观察者是一个“类”而不是一个“接
口”，更糟的是，它甚至没有实现一个接口。不幸的是，java.util.Observable的实现
有许多问题，限制了它的使用和复用。这并不是说它没有提供有用的功能，我们只
是想提醒大家注意一些事实。

**Observable是一个类**

你已经从我们的原则中得知这不是一件好事，但是，这到底会造成什么问题呢？
首先，因为Observable是一个“类”，你必须设计一个类继承它。如果某类想同时
具有Observable类和另一个超类的行为，就会陷入两难，毕竟Java不支持多重继承。
这限制了Observable的复用潜力（而增加复用潜力不正是我们使用模式最原始的动
机吗？）。
再者，因为没有Observable接口，所以你无法建立自己的实现，和Java内置的
Observer API搭配使用，也无法将java.util的实现换成另一套做法的实现

比方说，Observable将关键的方法保护起来。如果你看看Observable API，你会发现setChanged()方法被保护起来了（被定义成
protected）。那又怎么样呢？这意味着：除非你继承自Observable，否则你无法
创建Observable实例并组合到你自己的对象中来。这个设计违反了第二个设计原
则：“多用组合，少用继承”。

做什么呢？

如果你能够扩展java.util.Observable，那么Observable“可能”可以符合你的需求。
否则，你可能需要像本文开头的做法那样自己实现这一整套观察者模式。不管用
哪一种方法，反正你都已经熟悉观察者模式了，应该都能善用它们。