---
layout: post
title: JDK8 新特性之lambda表达式
date: 2017-07-13
tags: java
---

### lambda表达式

lambda表达式其实就是按一定语法，省略书写固定的代码，达到简化代码的效果。

### 要使用lambda表达式需要注明jdk8编译

```
  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.6.0</version>
        <configuration>
          <source>1.8</source>
          <target>1.8</target>
        </configuration>
      </plugin>
    </plugins>
  </build>
```
## lambda应用案例

### 集合排序

1. 普通的写法

   ```
   ArrayList<Integer> list = new ArrayList();
   Collections.sort(list); // 默认的是升序,升序排序
   ```

2. 使用lambda的写法：

   ```
   ArrayList<Integer> list = new ArrayList();
   list.sort((o1, o2) -> o2 - o1); // 降序
   list.sort(null); // 默认升序
   ```


### 对List集合中的User按照age的大小进行排序输出

1. 普通的写法
```
private static List<User> list=new ArrayList<User>();
    public static void main(String[] args) {
        list.add(new User(34));
        list.add(new User(14));
        list.add(new User(24));
        System.out.println("排序前："+list.toString());
        //对list集合的数据进行按照年龄排序
        Collections.sort(list, new Comparator<User>() {

            @Override
            public int compare(User o1, User o2) {
                // TODO Auto-generated method stub
                return Integer.compare(o1.age, o2.age);
            }
        });
        System.out.println("排序后："+list.toString());
    }

    ------------------------

    输出结果：

    排序前：[34, 14, 24]
    排序后：[14, 24, 34]
```

2. 使用lambda的写法：
```
private static List<User> list=new ArrayList<User>();
    public static void main(String[] args) {
        ......
        System.out.println("排序前："+list.toString());
        //对list集合的数据进行按照年龄排序(现在一行就可以代替上面的排序代码)
        Collections.sort(list, (o1,o2)->Integer.compare(o1.age, o2.age));
        System.out.println("排序后："+list.toString());
    }

    ------------------------

    输出结果：

    排序前：[34, 14, 24]
    排序后：[14, 24, 34]
```


### 新开一个子线程，并在子线程中输出“helloWord”

1. 普通的写法：
```
public static void main(String[] args) {
    new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println("HelloWord");
        }
    }).start();
}
```
2. 使用lambda的写法：
```
public static void main(String[] args) {
    //使用这个：()->Syso("HelloWord")表达式代替内部类，其实Syso("HelloWord")这个位置可以使用一个方法来代替
    new Thread( ()->System.out.println("HelloWord") ).start();
}
```


### 案例分析：

lambda表达式：其实就是省略书写固定的代码

下面的代码那些是固定的呢？那些是可以省略书写的呢？
```
//对list集合的数据进行按照年龄排序
Collections.sort(list, new Comparator<User>() {
    @Override
    public int compare(User o1, User o2) {
        return Integer.compare(o1.age, o2.age);
    }
});
```
可以省略书写的是：

    1. new Comparator() 这个是固定的，因为参数必须接受Comparator
    2. compare这个方法名也是可以省略
    3. compare这个方法的返回值和权限都可以省略

省略固定的代码后变成：

```
//对list集合的数据进行按照年龄排序
Collections.sort(list,
            (User o1, User o2)->{
        return Integer.compare(o1.age, o2.age);
    }
);
```
还有什么可以省略得呢？其实（User o1, User o2）的User也可以省略，因为list集合里存的都是User,JVM是可以猜测的出参数额类型。

省略固定的代码后变成：
```
//对list集合的数据进行按照年龄排序
Collections.sort(list,
            ( o1,  o2)->{
        return Integer.compare(o1.age, o2.age);
    }
);
```
还有什么可以省略得呢？其实return也可以省略，JVM是可以猜测的出返回类型。

修改变成：
```
//lambda表达式是：(o1,  o2)->(Integer.compare(o1.age, o2.age))。代替复杂内部类
Collections.sort(list, (o1,  o2) -> (Integer.compare(o1.age, o2.age)) );
```
既然要传list,那我可否直接用list排序,当然可以的,代码优化为:

```
list.sort((o1, o2) -> (Integer.compare(o1.getAge(), o2.getAge())));
```

### lambda表达式的基本语法

lambda表达式的基本语法：参数列表 -> 表达式

    参数列表：
    1.如果没有参数，直接用（）来表示。//如上需求2的（）->System.out.println("HelloWord")
    2.如果只有一个参数，并且参数写了类型，参数外面一定要加（）。
    3.如果只有一个参数，并且参数不写类型，那么这个参数外面可以不用加（。
    4.如果有两个或者多个参数，不管是否写参数类型，都要加（）。//如上需求1
    5.如果参数要加修饰符或者标签，参数一定要加上完整的类型。
    
    表达式：
    1.如果表达式只有一行，那么可以直接写（不需要{}）；
    2.如果表达式只有多行，需要用{}变成代码块；
    3.如果表达式是代码块，并且方法需要返回值，那么在代码块中就必须返回一个返回值；
    4.如果只有单行的情况，并且方法需要返回值，不能有return，编译器会自动帮我们推导return;
