---
layout: post
title: websocket 简介
date: 2018-03-12
tags: websocket
---



### websocket 简介

在我们做web项目的过程中，经常需要做的一个模块是消息模块。典型的场景：一个商城系统的后台管理，我想实现如果前台有客户下单，后台就会接到消息，以便尽快发货处理。

要实现上述的功能，我们有几种备选的方案。

方案1.使用ajax短轮询，比如每隔1分钟去请求一次服务器，让服务器去数据库去查询，看看有无新的未处理的订单，然后返回给客户端。

方案2.长轮询，长轮询的原理与上述类似，只不过采取了阻塞响应（response）的方法，也就是说只要服务器没有响应，这个请求就不断开，一直等到服务器有响应为止。

**ajax短轮询好比客户端每隔一段时间打一个电话给服务器，服务器不管有没有数据都要响应给客户端，响应完以后就挂掉电话，然后周而复始；**

**长轮询则是客户端打一个电话，开始一直等，直到服务器有响应，如果服务器一直不响应，这个请求就一直挂在那边。**

很显然，这两种方案都有各自弊端。

方案1：每隔一定时间去轮询服务器，这个时间的设置很关键，太长了，即时性得不到保证，太短了，有可能会造成服务器性能的浪费（主要是cpu）,假设在一个小时之内都没有一个订单，但是客户端还是不间断的每分钟发一次请求，这些请求就是浪费。

方案2：方案2的出现本来是为了解决方案1这种盲目不确定地发送请求造成浪费的弊端，但是它自己同样也有弊端，首先，它采取阻塞的方式来强迫连接长时间保持，而对于服务器而言，在同一个时间里面能处理的连接数（我们称之为程序的并发数）是有限的，而长轮询方式很容易造成服务端达到并发的限制，因为它不像短轮询一样会很快释放掉连接。

它们的共同的缺点是，每一次请求和响应，处理处理真正有用的数据，服务器和客户端还要交换一堆请求头，响应头等东西，信息交换的效率不高。事实上可以说，长轮询是一种伪长连接，它还是需要遵循http连接的规则：客户端请求--服务器响应--释放连接，顺便交换了一些相同的无用的信息。（造成带宽浪费）

websocket的原理网上有很多人也介绍了，简单来说，它就是html5中的一种协议，我的理解是，他是对html的长连接的一种升级。你也可以将它理解成一种长连接。只不过这种长连接相对于方案2的长轮询有以下优越之处。

1.首先，websocket连接只需要建立一次，在第一次连接的时候，客户端和服务器会交换必要的信息，如下所示：



![](/images/posts/websocket/1.png)



可以看到，websocket连接成功后返回的状态码是101.在请求头处，传递过来的connection类型是keep_alive，upgrade。也就是说是keep_alive的升级版。首先keep_alive是属于http1.1协议的范畴。大概的意思就是，在http1.0时代，我建立一个连接就是对应一次request--response的过程。而在1.1时代，新增加了keep-alive，我们可以保持这个连接的生命周期（可以通过nginx等服务器设置keepalive-timeout这个参数来实现），这样做的好处是可以自定义一个连接的存活时间，使得一个连接可以处理多个请求，而不是单单一次请求。设置了keepalive-timeout以后，当一个请求结束以后，我们在等keepalive-timeout这么长的时间，如果没有新的请求，就关闭这个连接。

说到http1.1，我们来看一个http的连接的请求头和响应头。

![](/images/posts/websocket/2.png)



看到了吧，不一样的地方就在于那个upgrade。所以我们可以这么说，websocket也是一个长连接。但是因为它是升级版，**所以它有个好处，就是它只需要建立一次连接，传递一次必要的请求头和响应头信息，之后再传递数据的时候就不需要在交换这些信息了。节省了带宽。**

2.**websocket是双向的，这也是他跟另外两种方法最大的不同，不管是ajax还是长轮询，他们都是通过客户端发送请求，服务器响应的形式完成信息的交换，这种模式下服务器处于一种被动的角色。而websocket不存在这个问题，websocket的链接一旦建立，服务器和客户端都可以互推信息。**



有了这两个优点，在做一些需要即时通信的功能时候，我们首选就是用websocket。

原文链接：http://www.cnblogs.com/roy-blog/p/7210484.html