<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junxin&#39;s Blog</title>
  
  <subtitle>A good memory is not as good as a rotten keyboard.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.smilexin.cn/"/>
  <updated>2021-06-03T06:58:39.549Z</updated>
  <id>https://blog.smilexin.cn/</id>
  
  <author>
    <name>何俊鑫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 高可用架构之MHA</title>
    <link href="https://blog.smilexin.cn/2021/06/03/MySQL%20%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8BMHA.html"/>
    <id>https://blog.smilexin.cn/2021/06/03/MySQL 高可用架构之MHA.html</id>
    <published>2021-06-02T16:00:00.000Z</published>
    <updated>2021-06-03T06:58:39.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司youshimaton（现就职于Facebook公司）开发，是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上保证数据的一致性，以达到真正意义上的高可用。</p><p><strong>该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）。</strong>MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。MHA Node运行在每台MySQL服务器上，MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明。</p><p>在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失，但这并不总是可行的。例如，如果主服务器硬件故障或无法通过ssh访问，MHA没法保存二进制日志，只进行故障转移而丢失了最新的数据。使用<a href="https://www.linuxidc.com/Linux/2018-04/151922.htm" target="_blank" rel="noopener">MySQL 5.5的半同步复制</a>，可以大大降低数据丢失的风险。MHA可以与半同步复制结合起来。如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性。</p><p>目前MHA主要支持一主多从的架构，<strong>要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器</strong>，一主二从，即一台充当master，一台充当备用master，另外一台充当从库，因为至少需要三台服务器，出于机器成本的考虑，淘宝也在该基础上进行了改造，目前淘宝TMHA已经支持一主一从。另外对于想快速搭建的可以参考：<a href="https://www.cnblogs.com/gomysql/p/6547797.html" target="_blank" rel="noopener">MHA快速搭建</a>。</p><p>我们自己使用其实也可以使用1主1从，但是master主机宕机后无法切换，以及无法补全binlog。master的mysqld进程crash后，还是可以切换成功，以及补全binlog的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司yoush
      
    
    </summary>
    
    
      <category term="Mysql" scheme="https://blog.smilexin.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装ffmpeg</title>
    <link href="https://blog.smilexin.cn/2021/06/01/Linux%20%E5%AE%89%E8%A3%85ffmpeg.html"/>
    <id>https://blog.smilexin.cn/2021/06/01/Linux 安装ffmpeg.html</id>
    <published>2021-05-31T16:00:00.000Z</published>
    <updated>2021-06-01T08:55:04.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装ffmpeg"><a href="#安装ffmpeg" class="headerlink" title="安装ffmpeg"></a>安装ffmpeg</h1><p>首先去官网下载源码包 <a href="http://ffmpeg.org/download.html#releases" target="_blank" rel="noopener">http://ffmpeg.org/download.html#releases</a></p><p>我这里下载的是ffmpeg-4.4.tar.gz，下载之后上传至Linux准备安装。</p><p>解压安装包，然后进到ffmpeg文件目录下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xjvf ffmpeg-4.4.tar.gz</span><br><span class="line">cd ffmpeg-4.4</span><br><span class="line">./configure --enable-shared --prefix=/usr/local/ffmpeg    //自己想要存放的地方</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p><strong>可能会报如下的错误：yasm/nasm 包不存在或者很旧</strong></p><p>出现这个错误需要安装yasm。下载地址：<a href="http://yasm.tortall.net/Download.html" target="_blank" rel="noopener">http://yasm.tortall.net/Download.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf yasm-1.3.0.tar.gz</span><br><span class="line">cd yasm-1.3.0/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>编译参数都是默认的，直接安装到系统中即可，安装成功之后继续回到ffmpeg解压后的目录，执行下面命令编译并安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-shared --prefix=/mydir/ffmpeg    //自己想要存放的地方</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p><p>这里编译时间非常长，等待的时间可以去喝杯coffee压压惊</p><p>好了之后执行<code>cd /mydir/ffmpeg</code> 进入安装目录，查看一下发现有bin,include,lib,share这4个目录，其中bin是ffmpeg主程序二进制目录，include是C/C++头文件目录，lib是编译好的库文件目录，share是文档目录，然后进入bin目录，执行 <code>./ffmpeg -version</code> 查看当前版本的详细信息，默认情况下一般会报libavdevice.so.57: cannot open shared object file: No such file or directory，原因是lib目录未加载到链接到系统库中。</p><p>添加这些库：<code>vi /etc/ld.so.conf</code><br>添加一行内容： <code>/mydir/ffmpeg/lib</code><br>保存并退出<br>然后执行 <code>sudo ldconfig</code> 重新加载资源<br>使配置生效，现在再次执行 <code>./ffmpeg -version</code> 显示就正常了</p><p>然后可以根据需要将bin目录添加至环境变量中以保证任何时候都能使用ffmpeg命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure></p><p>添加下面这行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=/mydir/ffmpeg/bin:$PATH</span><br></pre></td></tr></table></figure></p><p>保存退出，运行profile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>全局ffmpeg生效<br>到这ffmpeg安装完成并且生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装ffmpeg&quot;&gt;&lt;a href=&quot;#安装ffmpeg&quot; class=&quot;headerlink&quot; title=&quot;安装ffmpeg&quot;&gt;&lt;/a&gt;安装ffmpeg&lt;/h1&gt;&lt;p&gt;首先去官网下载源码包 &lt;a href=&quot;http://ffmpeg.org/download
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.smilexin.cn/tags/Linux/"/>
    
      <category term="ffmpeg" scheme="https://blog.smilexin.cn/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>我的健身记录贴</title>
    <link href="https://blog.smilexin.cn/2021/05/25/%E6%88%91%E7%9A%84%E5%81%A5%E8%BA%AB%E8%AE%B0%E5%BD%95%E8%B4%B4.html"/>
    <id>https://blog.smilexin.cn/2021/05/25/我的健身记录贴.html</id>
    <published>2021-05-24T16:00:00.000Z</published>
    <updated>2021-06-09T08:05:18.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总计"><a href="#总计" class="headerlink" title="总计"></a>总计</h1><p>从2021-05-25开始正式记录训练内容起累积训练 <strong>11</strong> 天</p><h1 id="三分化训练和五分化训练"><a href="#三分化训练和五分化训练" class="headerlink" title="三分化训练和五分化训练"></a>三分化训练和五分化训练</h1><ul><li>五分化<br>胸背腿肩臂</li><li>三分化<br>3分化训练计划主要分为推，拉，腿。主练大肌群，小肌群最后做两个动作，一个四组就行了，推，拉，腿。<ul><li>推：平板卧推，上斜卧推，高位龙门架夹胸，推肩，杠铃推举，哑铃推举，侧平举，然后三头来两个动作，一个四组。</li><li>拉：引体向上，杠铃划船，高位下拉，坐姿划船，绳索面拉练肩后束，然后练二头。</li><li>腿就不用说了吧</li></ul></li></ul><h1 id="增肌饮食推荐"><a href="#增肌饮食推荐" class="headerlink" title="增肌饮食推荐"></a>增肌饮食推荐</h1><p>每kg体重1.5-2g蛋白</p><p>每kg体重碳水3g</p><p>每kg体重脂肪1g</p><p>3-4次力量穿插2次低强度有氧促进恢复</p><p>只要不吃火锅汉堡什么的，不会很肥的</p><p>训练方法以偏向力量举为主 不要太沉迷于孤立训练</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li>哑铃重量为单个哑铃。<blockquote><p>例：双手各拿10kg的哑铃进行卧推，则记录哑铃卧推10kg。</p></blockquote></li><li>杠铃重量为整体的片。<blockquote><p>例：杠铃左右各上5kg的片进行卧推，则记录杠铃卧推10kg。</p></blockquote></li><li>固定器械则为插销的标记重量。</li></ul><h1 id="动作提醒"><a href="#动作提醒" class="headerlink" title="动作提醒"></a>动作提醒</h1><h2 id="哑铃卧推"><a href="#哑铃卧推" class="headerlink" title="哑铃卧推"></a>哑铃卧推</h2><p>哑铃卧推肘部微微内收可以极大减小对肩部的压力。具体角度自己可以先用小重量感受。</p><h1 id="2021-05-25-星期二（肩）"><a href="#2021-05-25-星期二（肩）" class="headerlink" title="2021-05-25 星期二（肩）"></a>2021-05-25 星期二（肩）</h1><h2 id="今日体重"><a href="#今日体重" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容"><a href="#训练内容" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>哑铃侧平举4kg 12 12 12 12</li><li>坐姿俯身哑铃侧平举4kg（训练后束） 8 8 8 8</li><li>坐姿哑铃推举<ul><li>10kg 10 11 12 10</li><li>12kg 8 8 8</li></ul></li><li>史密斯颈后推举5kg 8 8 8</li><li>龙门架绳索面拉（8kg?）（后束）8 8 8</li><li>哑铃8kg/曲杆杠铃15kg提拉 8 8 8</li></ul><h1 id="2021-05-26-星期三（胸）"><a href="#2021-05-26-星期三（胸）" class="headerlink" title="2021-05-26 星期三（胸）"></a>2021-05-26 星期三（胸）</h1><h2 id="今日体重-1"><a href="#今日体重-1" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-1"><a href="#训练内容-1" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>平躺哑铃热身胸部</li><li>蝴蝶机夹胸18kg 20 16 12</li><li>哑铃上斜卧推<ul><li>8kg 12</li><li>10kg 10</li><li>12kg 10</li><li>14kg 8 10 11 10</li><li>16kg 7 8 8</li></ul></li><li>杠铃上斜卧推10kg 6 7 6</li><li>固定器械把座椅垫高推下胸<ul><li>27kg 8 12</li><li>36kg 8 8 10</li></ul></li><li>俯身双杠臂屈伸（下胸）54kg↑ 10 10 10</li><li>蝴蝶机夹胸27kg 10 10 10 10</li></ul><h2 id="练后总结"><a href="#练后总结" class="headerlink" title="练后总结"></a>练后总结</h2><p>胸部充血良好,今天更喜欢哑铃卧推,感觉杠铃推起来有点别手。</p><h1 id="2021-05-27-星期四（背）"><a href="#2021-05-27-星期四（背）" class="headerlink" title="2021-05-27 星期四（背）"></a>2021-05-27 星期四（背）</h1><h2 id="今日体重-2"><a href="#今日体重-2" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-2"><a href="#训练内容-2" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>直臂下压练背27kg 12 12 8 8</li><li>宽距引体向上59kg↑ 8 8 8 8</li><li>麒麟抱拉15kg 12 12 12 12</li><li>划船超级组(ab动作一轮为一组，动作a做了立马做动作b)<blockquote><ul><li>动作a：器械单手划船12.5kg 10 10 10 10</li><li>动作b：器械双手划船25kg 6 8 10 8</li></ul></blockquote></li></ul><h1 id="2021-05-28-星期五（腿-amp-手臂）"><a href="#2021-05-28-星期五（腿-amp-手臂）" class="headerlink" title="2021-05-28 星期五（腿&amp;手臂）"></a>2021-05-28 星期五（腿&amp;手臂）</h1><h2 id="今日体重-3"><a href="#今日体重-3" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-3"><a href="#训练内容-3" class="headerlink" title="训练内容"></a>训练内容</h2><p>快走15分钟热身</p><ul><li>杠铃负重深蹲<ul><li>10kg 10</li><li>20kg 8 9 8 8</li></ul></li><li>坐姿蹬腿<ul><li>33kg 10 12</li><li>44kg 12</li><li>56kg 8 10</li></ul></li><li>坐姿腿屈伸27kg 10 9 9 9</li><li>杠铃弯举15kg 10 9 8 8</li><li>绳索下压<ul><li>27.3kg 10</li><li>34.1kg 6 6 6</li><li>20.5kg 8 9 9</li></ul></li></ul><h1 id="2021-05-30-星期天（推：胸、肩、三头）"><a href="#2021-05-30-星期天（推：胸、肩、三头）" class="headerlink" title="2021-05-30 星期天（推：胸、肩、三头）"></a>2021-05-30 星期天（推：胸、肩、三头）</h1><h2 id="今日体重-4"><a href="#今日体重-4" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-4"><a href="#训练内容-4" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>坐姿哑铃推举<ul><li>10kg 12</li><li>12kg 12</li><li>14kg 8 8 8 6</li></ul></li><li>哑铃侧平举6kg 8 9 8 8</li><li><p>俯身哑铃侧平举4kg 9 13 12 12</p></li><li><p>上斜哑铃推胸</p><ul><li>8kg 10</li><li>12kg 14</li><li>16kg 8 9 9 7</li></ul></li><li>固定器械把座椅垫高推下胸<ul><li>32kg 10</li><li>45kg 8 8 7 6</li></ul></li><li>蝴蝶机夹胸27kg 12 12 12 12</li><li>绳索下拉<ul><li>20.5kg 13</li><li>27.3kg 8 8 7 6 </li></ul></li><li>爬梯10分钟</li></ul><h1 id="2021-05-31-星期一（拉：背、肩后束）"><a href="#2021-05-31-星期一（拉：背、肩后束）" class="headerlink" title="2021-05-31 星期一（拉：背、肩后束）"></a>2021-05-31 星期一（拉：背、肩后束）</h1><h2 id="今日体重-5"><a href="#今日体重-5" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-5"><a href="#训练内容-5" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>引体向上 1 1 1.5</li><li>宽距助力引体45kg↑ 8 7 4 7</li><li>固定重量杠铃划船25kg 10 12 13 15</li><li>2.2米杠铃划船15kg 9 10 11</li><li>高位下拉32kg 8 8 8 8</li><li>坐姿划船<ul><li>41kg 8</li><li>36kg 8 8</li></ul></li><li>绳索面拉练肩后束20.5kg 8 8 8 8</li><li>哑铃弯举8kg 8 8 8 8.5</li></ul><h1 id="2021-06-01-星期二（腿）"><a href="#2021-06-01-星期二（腿）" class="headerlink" title="2021-06-01 星期二（腿）"></a>2021-06-01 星期二（腿）</h1><h2 id="今日体重-6"><a href="#今日体重-6" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-6"><a href="#训练内容-6" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>倒蹬20kg 12 13 12 13</li><li>哈克深蹲30kg 8 8 8 8</li><li>史密斯深蹲20kg 8 8 8 8</li><li>坐姿腿屈伸23kg 10 10 10 11 9</li></ul><h1 id="2021-06-02-星期三（胸）"><a href="#2021-06-02-星期三（胸）" class="headerlink" title="2021-06-02 星期三（胸）"></a>2021-06-02 星期三（胸）</h1><h2 id="今日体重-7"><a href="#今日体重-7" class="headerlink" title="今日体重"></a>今日体重</h2><p>刚吃完午饭：70kg</p><h2 id="训练内容-7"><a href="#训练内容-7" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>蝴蝶机夹胸27kg 12 12 12 12</li><li>上斜哑铃推胸<ul><li>12kg 12</li><li>14kg 8</li><li>16kg 9 8 8 9</li></ul></li><li>平板哑铃推胸<ul><li>14kg 8</li><li>16kg 8</li></ul></li><li>平板杠铃卧推20kg 5 5 4.5 2.5 3</li><li>固定器械把座椅垫高推下胸<ul><li>45kg 3</li><li>41kg 5 5 5 4.8</li></ul></li></ul><h2 id="练后总结-1"><a href="#练后总结-1" class="headerlink" title="练后总结"></a>练后总结</h2><p>胸部充血良好,平板哑铃卧推做完起身困难。</p><h1 id="2021-06-03-星期四（背）"><a href="#2021-06-03-星期四（背）" class="headerlink" title="2021-06-03 星期四（背）"></a>2021-06-03 星期四（背）</h1><h2 id="今日体重-8"><a href="#今日体重-8" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-8"><a href="#训练内容-8" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>宽距助力引体45kg↑ 8 8 8 6</li><li>直臂下压练背<ul><li>20.5kg 12 8 7</li><li>27.3kg 7 8</li></ul></li><li>2.2米杠铃划船<ul><li>10kg 12</li><li>15kg 12 10 12 12</li></ul></li><li>麒麟抱拉15kg 12 12 12 12</li><li>坐姿划船30kg 9 9 8.8 8</li></ul><h1 id="2021-06-04-星期五（腿）"><a href="#2021-06-04-星期五（腿）" class="headerlink" title="2021-06-04 星期五（腿）"></a>2021-06-04 星期五（腿）</h1><h2 id="今日体重-9"><a href="#今日体重-9" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-9"><a href="#训练内容-9" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>深蹲40kg 8 8 9 8</li><li>倒蹬30kg 12 12 12 12</li><li>单腿蹬23kg 6 9 8 8</li><li>坐姿腿屈伸<ul><li>36kg 7 7</li><li>27kg 8 8 10</li></ul></li></ul><h1 id="2021-06-05-星期六（肩-amp-手臂）"><a href="#2021-06-05-星期六（肩-amp-手臂）" class="headerlink" title="2021-06-05 星期六（肩&amp;手臂）"></a>2021-06-05 星期六（肩&amp;手臂）</h1><h2 id="今日体重-10"><a href="#今日体重-10" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-10"><a href="#训练内容-10" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>坐姿哑铃推举<ul><li>8kg 12</li><li>10kg 9</li><li>12kg 8</li><li>14kg 8 10 8 6</li></ul></li><li>固定器械推举 前束 <ul><li>20kg 8</li><li>30kg 5 3</li><li>10kg 8 5</li></ul></li><li>哑铃侧平举 6kg 8 9 8 8</li><li>坐姿俯身哑铃侧平举6kg 8 9 9 8</li><li>史密斯颈后推举<ul><li>10kg 12</li><li>15kg 8 6 6 6</li></ul></li><li>绳索下拉（三头）23kg 10 8 8 8</li><li>牧师凳杠铃弯举（二头）20kg 9 8 7 6</li><li>双杠臂屈伸（三头） 5 5 5 5</li><li>腹肌抬腿 12 12 12 12</li></ul><h1 id="2021-06-08-星期二（胸）"><a href="#2021-06-08-星期二（胸）" class="headerlink" title="2021-06-08 星期二（胸）"></a>2021-06-08 星期二（胸）</h1><h2 id="今日体重-11"><a href="#今日体重-11" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-11"><a href="#训练内容-11" class="headerlink" title="训练内容"></a>训练内容</h2><h3 id="中午"><a href="#中午" class="headerlink" title="中午"></a>中午</h3><ul><li>上斜哑铃推胸<ul><li>10kg 12</li><li>12kg 10</li><li>16kg 8</li><li>18kg 8 8 9 8<h3 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h3></li></ul></li><li>蝴蝶机夹胸32kg 12 12 12 8 5</li><li>俯卧撑 10 10 10</li><li>上斜哑铃推胸16kg 6 8 8</li><li>平板杠铃卧推<ul><li>30kg 8</li><li>35kg 8 8 6 3<h2 id="练后总结-2"><a href="#练后总结-2" class="headerlink" title="练后总结"></a>练后总结</h2>杠铃卧推差点受伤，没人保护就不要太勉强…</li></ul></li></ul><h1 id="2021-06-08-星期三（背）"><a href="#2021-06-08-星期三（背）" class="headerlink" title="2021-06-08 星期三（背）"></a>2021-06-08 星期三（背）</h1><h2 id="今日体重-12"><a href="#今日体重-12" class="headerlink" title="今日体重"></a>今日体重</h2><p>未称重</p><h2 id="训练内容-12"><a href="#训练内容-12" class="headerlink" title="训练内容"></a>训练内容</h2><ul><li>宽距助力引体<ul><li>36kg↑ 6 6 6 3.8</li><li>45kg 3</li></ul></li><li>直臂下压<ul><li>18kg 8</li><li>23kg 8 8 8</li></ul></li><li>高位下拉27kg 8 8 8 12</li><li>麒麟抱拉20kg 12 12 12</li><li>哑铃划船<ul><li>10kg 12</li><li>12kg 8 10 12</li></ul></li><li>杠铃划船20kg 12 12 12</li><li>龙门架划船<ul><li>36kg 12 12</li><li>45kg 12 12 12 12<h2 id="练后总结-3"><a href="#练后总结-3" class="headerlink" title="练后总结"></a>练后总结</h2>龙门架划船简直不要太爽，背炸了。哈哈哈哈哈</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总计&quot;&gt;&lt;a href=&quot;#总计&quot; class=&quot;headerlink&quot; title=&quot;总计&quot;&gt;&lt;/a&gt;总计&lt;/h1&gt;&lt;p&gt;从2021-05-25开始正式记录训练内容起累积训练 &lt;strong&gt;11&lt;/strong&gt; 天&lt;/p&gt;
&lt;h1 id=&quot;三分化训练和五分化
      
    
    </summary>
    
    
      <category term="健身" scheme="https://blog.smilexin.cn/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>windows使用NVM管理nodejs版本</title>
    <link href="https://blog.smilexin.cn/2021/05/21/windows%E4%BD%BF%E7%94%A8NVM%E7%AE%A1%E7%90%86nodejs%E7%89%88%E6%9C%AC.html"/>
    <id>https://blog.smilexin.cn/2021/05/21/windows使用NVM管理nodejs版本.html</id>
    <published>2021-05-20T16:00:00.000Z</published>
    <updated>2021-05-21T03:22:14.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>比如我们手上同时在做好几个项目，这些项目的需求都不太一样，导致了这些个项目需要依赖的nodejs版本也不同，这种情况下，我们就可以通过nvm来切换nodejs的版本，而不需要频繁地下载/卸载不同版本的nodejs来满足当前项目的要求。</p><h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><blockquote><p>下载地址：<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p></blockquote><p>可下载以下版本：</p><ul><li>nvm-noinstall.zip：绿色免安装版，但使用时需要进行配置。</li><li>nvm-setup.zip：安装版，推荐使用</li></ul><blockquote><p><strong>安装的时候注意安装目录不要出现中文和空格。</strong></p></blockquote><p>检查是否安装成功</p><p>打开CMD，输入nvm，安装成功则会如下图所示，它会显示出当前nvm版本以及nvm的命令</p><h1 id="使用nvm"><a href="#使用nvm" class="headerlink" title="使用nvm"></a>使用nvm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nvm list // 显示已安装的版本（同 nvm list installed）</span><br><span class="line">nvm list installed // 显示已安装的版本</span><br><span class="line">nvm list available // 显示所有可以下载的版本</span><br><span class="line">nvm install 12.22.1 // 安装12.22.1版本node</span><br><span class="line">nvm install latest // 安装最新版本node</span><br><span class="line">nvm use 12.22.1 // 使用14.5.0版本node</span><br><span class="line">nvm uninstall 14.5.0 // 卸载14.5.0版本node</span><br></pre></td></tr></table></figure><blockquote><p>在运行nvm install 的时候，有可能会出现无权限安装的问题，如果遇到此问题，请以管理员身份运行cmd。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;比如我们手上同时在做好几个项目，这些项目的需求都不太一样，导致了这些个项目需要依赖的nodejs版本也不同，这种情况下，我们就可以通过nvm
      
    
    </summary>
    
    
      <category term="nodejs" scheme="https://blog.smilexin.cn/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 常用语法</title>
    <link href="https://blog.smilexin.cn/2021/05/12/Markdown%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95.html"/>
    <id>https://blog.smilexin.cn/2021/05/12/Markdown 常用语法.html</id>
    <published>2021-05-11T16:00:00.000Z</published>
    <updated>2021-05-14T12:23:54.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入<code>html</code>标签。</p><blockquote><p>注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效！</p></blockquote><h1 id="Markdown的常用语法"><a href="#Markdown的常用语法" class="headerlink" title="Markdown的常用语法"></a>Markdown的常用语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>用<code>#</code>标记</p><p>在 标题开头 加上1~6个<code>#</code>，依次代表一级标题、二级标题….六级标题</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表使用<code>-</code>、<code>+</code>和<code>*</code>作为列表标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- Red</span><br><span class="line">- Green</span><br><span class="line">- Blue</span><br><span class="line"></span><br><span class="line">* Red</span><br><span class="line">* Green</span><br><span class="line">* Blue</span><br><span class="line"></span><br><span class="line">+ Red</span><br><span class="line">+ Green</span><br><span class="line">+ Blue</span><br></pre></td></tr></table></figure><p>效果如下</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><ul><li>Red</li><li>Green</li><li>Blue</li></ul><ul><li>Red</li><li>Green</li><li>Blue</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表则使用数字加英文句点.来表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Red</span><br><span class="line">2. Green</span><br><span class="line">3. Blue</span><br></pre></td></tr></table></figure></p><p>效果如下</p><ol><li>Red</li><li>Green</li><li>Blue</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用以<code>&gt;</code>来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。</p><p>常见的引用写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一段引用    //在`&gt;`后面有 1 个空格</span><br><span class="line">&gt; </span><br><span class="line">&gt;     这是引用的代码块形式    //在`&gt;`后面有 5 个空格</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 代码例子：</span><br><span class="line">&gt;   </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&gt; 一级引用</span><br><span class="line">&gt; &gt; 二级引用</span><br><span class="line">&gt; &gt; &gt; 三级引用</span><br><span class="line"></span><br><span class="line">&gt; #### 这是一个四级标题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1. 这是第一行列表项</span><br><span class="line">&gt; 2. 这是第二行列表项</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><blockquote><p>这是一段引用    //在<code>&gt;</code>后面有 1 个空格</p><pre><code>这是引用的代码块形式    //在`&gt;`后面有 5 个空格</code></pre><p>代码例子：</p><pre><code>protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);}</code></pre></blockquote><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><blockquote><h4 id="这是一个四级标题"><a href="#这是一个四级标题" class="headerlink" title="这是一个四级标题"></a>这是一个四级标题</h4><ol><li>这是第一行列表项</li><li>这是第二行列表项</li></ol></blockquote><h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>两个<code>*</code>或-代表加粗，一个<code>*</code>或<code>-</code>代表斜体，<code>~~</code>代表删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**加粗文本** 或者 __加粗文本__</span><br><span class="line"></span><br><span class="line">*斜体文本*  或者_斜体文本_</span><br><span class="line"></span><br><span class="line">~~删除文本~~</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><strong>加粗文本</strong> 或者 <strong>加粗文本</strong></p><p><em>斜体文本</em>  或者<em>斜体文本</em></p><p><del>删除文本</del></p><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><p>图片与链接的语法很像，区别在一个 ! 号。二者格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图片：![]()    ![图片文本(可忽略)](图片地址)</span><br><span class="line"></span><br><span class="line">链接：[]()     [链接文本](链接地址)</span><br></pre></td></tr></table></figure></p><p>链接又分为行内式、参考式和 自动链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">这是行内式链接：[Junxin&apos;s Blog](https://smilexin.cn/)。</span><br><span class="line"></span><br><span class="line">这是参考式链接：[Junxin&apos;s Blog][url]，其中url为链接标记，可置于文中任意位置。</span><br><span class="line"></span><br><span class="line">[url]: https://smilexin.cn// &quot;Junxin&apos;s Blog&quot;</span><br><span class="line"></span><br><span class="line">链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</span><br><span class="line"></span><br><span class="line">这是自动链接：直接使用`&lt;&gt;`括起来&lt;https://smilexin.cn/&gt;</span><br><span class="line"></span><br><span class="line">这是图片：![][avatar]</span><br><span class="line"></span><br><span class="line">[avatar]: https://connorlin.github.io/images/avatar.jpg</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><p>这是行内式链接：<a href="https://smilexin.cn/" target="_blank" rel="noopener">Junxin’s Blog</a>。</p><p>这是参考式链接：<a href="https://smilexin.cn//" title="Junxin&#39;s Blog" target="_blank" rel="noopener">Junxin’s Blog</a>，其中url为链接标记，可置于文中任意位置。</p><p>链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</p><p>这是自动链接：直接使用<code>&lt;&gt;</code>括起来<a href="https://smilexin.cn/" target="_blank" rel="noopener">https://smilexin.cn/</a></p><p>这是图片：<img src="https://smilexin.cn/img/avatar.jpg" alt=""></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码分为行内代码和代码块。</p><ul><li>行内代码使用 `代码` 标识，可嵌入文字中</li><li>代码块使用4个空格或```标识</li></ul><p>```<br>这里是代码<br>```</p><p>代码语法高亮在 ```后面加上空格和语言名称即可<br>``` 语言<br>//注意语言前面有空格<br>这里是代码<br>```</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这是行内代码`onCreate(Bundle savedInstanceState)`的例子。</span><br><span class="line"></span><br><span class="line">这是代码块和语法高亮：</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">// 注意java前面有空格</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：<br>这是行内代码<code>onCreate(Bundle savedInstanceState)</code>的例子。</p><p>这是代码块和语法高亮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意java前面有空格</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格对齐格式</p><ul><li>居左：<code>:----</code></li><li>居中：<code>:----:</code>或<code>-----</code></li><li>居右：<code>----:</code><br>例子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试文本|居中测试文本|居右测试文本|</span><br><span class="line">|居左测试文本1|居中测试文本2|居右测试文本3|</span><br><span class="line">|居左测试文本11|居中测试文本22|居右测试文本33|</span><br><span class="line">|居左测试文本111|居中测试文本222|居右测试文本333|</span><br></pre></td></tr></table></figure><p>效果如下：<br>|标题|标题|标题|<br>|:—|:—:|—:|<br>|居左测试文本|居中测试文本|居右测试文本|<br>|居左测试文本1|居中测试文本2|居右测试文本3|<br>|居左测试文本11|居中测试文本22|居右测试文本33|<br>|居左测试文本111|居中测试文本222|居右测试文本333|</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>在一行中用三个以上的<code>*</code>、<code>-</code>、<code>_</code>来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br><span class="line"></span><br><span class="line">* * *</span><br></pre></td></tr></table></figure></p><p>效果均为一条分割线：</p><hr><hr><hr><hr><h1 id="Markdown常用的Html标签"><a href="#Markdown常用的Html标签" class="headerlink" title="Markdown常用的Html标签"></a>Markdown常用的Html标签</h1><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;</span><br><span class="line">&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><font face="微软雅黑" color="red" size="6">字体及字体颜色和大小</font></p><p><font color="#0000ff">字体颜色</font></p><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用html标签`&lt;br/&gt;`&lt;br/&gt;换行</span><br></pre></td></tr></table></figure><p>效果如下：<br>使用html标签<code>&lt;br/&gt;</code><br>第二行</p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>效果如下：<br><u>下划线文本</u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时
      
    
    </summary>
    
    
      <category term="Markdown" scheme="https://blog.smilexin.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>谁动了我的 Linux？history 命令详解！</title>
    <link href="https://blog.smilexin.cn/2021/05/12/%E8%B0%81%E5%8A%A8%E4%BA%86%E6%88%91%E7%9A%84%20Linux.html"/>
    <id>https://blog.smilexin.cn/2021/05/12/谁动了我的 Linux.html</id>
    <published>2021-05-11T16:00:00.000Z</published>
    <updated>2021-05-12T02:42:24.310Z</updated>
    
    <content type="html"><![CDATA[<p>当我们频繁使用 Linux 命令行时，有效地使用历史记录，可以大大提高工作效率。</p><p>在平时 Linux 操作过程中，很多命令是重复的，你一定不希望大量输入重复的命令。如果你是系统管理员，你可能需要对用户操作进行审计，管理好 Linux 命令历史记录显得非常重要。</p><p>今天我们来介绍一下，在 Linux 使用 history 来减少重复命令的几个实用技巧。</p><h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/bash_history/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Linux 命令的历史记录，会持久化存储，默认位置是当前用户<code>home</code>目录的 <code>.bash_history</code> 文件。</p><p>当 Linux 系统启动一个 Shell 时，Shell 会从 <code>.bash_history</code>文件中，读取历史记录，存储在相应内存的缓冲区中。</p><p>我们平时所操作的 Linux 命令，都会记录在<strong>缓冲区</strong>中。包括 history 命令所执行的历史命令管理，都是记录在<strong>缓冲区</strong>，而不是直接记录到 <code>.bash_history</code> 文件。</p><p>当我们退出 Shell，比如按下 <code>Ctrl+D</code> 时，Shell 进程会把缓冲区的内容，写回到 <code>.bash_history</code> 文件中去。</p><h1 id="使用详解"><a href="#使用详解" class="headerlink" title="使用详解"></a>使用详解</h1><p>清楚了 <code>history</code> 的基本原理，我们来具体学习一下如何使用它。</p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>直接输入 history 命令，可以看到最近操作的所有命令都显示出来了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history</span><br></pre></td></tr></table></figure></p><p>有时候我不需要显示所有的历史命令，只显示最后的 10 条历史记录，可以在命令后加数字 <code>N</code> 即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history 10</span><br></pre></td></tr></table></figure></p><p>正常情况下，只有在 Shell 正常退出时，才会将缓冲区内容保存到文件。如果你想主动保存缓冲区的历史记录，执行 <code>-w</code> 选项即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history -w</span><br></pre></td></tr></table></figure></p><p>当然，如果你执行了一些敏感的命令操作，可以执行 <code>-c</code> 将缓冲区内容直接删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ history -c</span><br></pre></td></tr></table></figure></p><h2 id="重复执行命令"><a href="#重复执行命令" class="headerlink" title="重复执行命令"></a>重复执行命令</h2><p>如果要重复执行一些命令，可以使用 <code>!</code> 来快速执行重复的命令。</p><p>举个例子，重复执行第 <code>1024</code> 历史命令，可以执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ !1024</span><br></pre></td></tr></table></figure><p><code>1024</code> 这个编号可以通过 <code>history</code> 查看</p><p>重复执行上一条命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ !!</span><br></pre></td></tr></table></figure><p>重复执行倒数第 6 条历史命令，可以通过负数表示，-6 表示倒数第 6 条记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ !-6</span><br></pre></td></tr></table></figure><h2 id="搜索历史命令"><a href="#搜索历史命令" class="headerlink" title="搜索历史命令"></a>搜索历史命令</h2><p>有时候，需要重复执行某字符串开头的最后一个命令，同样可以通过 ! 来操作，然后按 Enter 执行即可</p><p>比如，刚才执行了一个很长命令，只记录命令开头是 <code>curl</code>，这时就可以通过 <code>!curl</code> 快速执行该命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ !curl</span><br></pre></td></tr></table></figure></p><p>这个用法很高效，但存在不安全因素，因为有可能执行的命令不是你想要执行的，那就坏事了。可以通过 <code>:p</code> 来安全地执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ !curl:p</span><br><span class="line">curl www.sina.com.cn</span><br></pre></td></tr></table></figure></p><p>加上 <code>:p</code> 后，只是打印出了搜索到的命令，如果要执行，请按 <code>Up</code> 键，然后回车即可。</p><p>如果你只知道某条命令包含了 “hi” 信息，不是以 “hi” 开头，同样可以通过 ? 来执行包含字符串的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ !?hi</span><br></pre></td></tr></table></figure><h2 id="交互式搜索历史命令"><a href="#交互式搜索历史命令" class="headerlink" title="交互式搜索历史命令"></a>交互式搜索历史命令</h2><p>在 Linux 搜索历史命令，还可以通过交互式的搜索方式，简直高效直接。在命令行输入 Ctrl+R 后，进入交互界面，键入需要搜索的关键字，如果匹配到多条命令，可以多次键入 Ctrl+R 来切换上一条匹配的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(reverse-i-search)`sina&apos;: echo sina</span><br></pre></td></tr></table></figure></p><p>可以看到，我输入了 sina 后，就自动匹配到最近一次和 sina 匹配的命令，这时按下回车就可以执行该命令。</p><h2 id="重复执行上条命令"><a href="#重复执行上条命令" class="headerlink" title="重复执行上条命令"></a>重复执行上条命令</h2><p>在这里总结下多种重复执行上条命令的方式，你可以选择一种自己喜欢的就可以啦</p><ul><li>!!</li><li>!-1</li><li>Ctrl+p</li><li>Up</li></ul><h2 id="显示命令时间"><a href="#显示命令时间" class="headerlink" title="显示命令时间"></a>显示命令时间</h2><p>有时候需要对 Linux 系统做审计，那为历史记录添加时间显示非常有用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ export HISTTIMEFORMAT=&apos;%F %T &apos;</span><br><span class="line">$ history 3</span><br><span class="line">    8  2021-05-12 10:29:48 echo sina</span><br><span class="line">    9  2021-05-12 10:32:13 export HISTTIMEFORMAT=&apos;%F %T &apos;</span><br><span class="line">   10  2021-05-12 10:32:17 history</span><br></pre></td></tr></table></figure></p><p>可以看到，历史记录已经显示了时间。其实这些对于审计需求，还不够，可以加上更详细的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ export HISTTIMEFORMAT=&quot;%F %T `who -u am i 2&gt;/dev/null| awk &apos;&#123;print $NF&#125;&apos;|sed \-e &apos;s/[()]//g&apos;` `whoami` &quot;</span><br><span class="line">  6  2021-04-18 16:07:48 14.116.240.195 root ls</span><br><span class="line">  7  2021-04-18 16:07:59 14.116.240.195 root pwd</span><br><span class="line">  8  2021-04-18 16:08:14 14.116.240.195 root history</span><br></pre></td></tr></table></figure></p><h2 id="控制历史记录总数"><a href="#控制历史记录总数" class="headerlink" title="控制历史记录总数"></a>控制历史记录总数</h2><p>默认情况下，Linux 系统最多存储 1000 条历史记录，可以通过 <code>HISTSIZE</code> 环境变量查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $HISTSIZE</span><br><span class="line">1000</span><br></pre></td></tr></table></figure></p><p>对于需要做审计的场景，1000 条历史记录可能会太少了，我们可以修改为合适的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ export HISTSIZE=10000</span><br></pre></td></tr></table></figure></p><p>注意，<code>HISTSIZE</code> 变量只能控制缓冲区中的历史记录数量，如果需要控制 <code>bash_history</code> 文件存储的最大记录数，可以通过 <code>HISTFILESIZE</code> 进行控制<br>上述命令行修改只在当前 Shell 环境生效，如果需要永久生效，需要写入配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;export HISTSIZE=10000&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">$ echo &quot;export HISTFILESIZE=200000&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">$ source ~/.bash_profile</span><br></pre></td></tr></table></figure></p><h2 id="更改历史记录文件名"><a href="#更改历史记录文件名" class="headerlink" title="更改历史记录文件名"></a>更改历史记录文件名</h2><p>有时，为了方便管理和备份，需要更改历史记录文件的路径和名称。简单，同样可以通过环境变量 <code>HISTFILE</code> 更改它的文件名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;export HISTFILE=/data/backup/chopin.bash_history&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">$ souce ~/.bash_profile</span><br></pre></td></tr></table></figure><h2 id="禁用历史记录"><a href="#禁用历史记录" class="headerlink" title="禁用历史记录"></a>禁用历史记录</h2><p>处于某种特殊环境，我们需要禁用历史记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;export HISTSIZE=0&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">$ echo &quot;export HISTFILESIZE=0&quot; &gt;&gt; ~/.bash_profile</span><br><span class="line">$ source ~/.bash_profile</span><br></pre></td></tr></table></figure><p>直接把上述两个变量的值设置为 0，就实现了禁用历史记录的功能</p><h2 id="黑客必知的一个小技巧"><a href="#黑客必知的一个小技巧" class="headerlink" title="黑客必知的一个小技巧"></a>黑客必知的一个小技巧</h2><p>最后分享一个不为人知的，黑客必知的小技巧。</p><p>在命令前额外多加一个空格，这样的命令是不会被记录到历史记录的，感觉是不是很酷</p><p>这个技巧如果在你的系统不管用，请查看下环境变量 <code>HISTCONTROL</code> 是否包含 <code>ignorespace</code>，貌似 centos 系统默认没有设置这个值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在 Linux 系统，<code>history</code> 命令可以非常方便，帮助我们管理历史命令，平时我们命令都会先记录在缓存区，在 Shell 退出时才会记录到文件中。</p><p><code>history</code> 命令提供了很方便的管理功能，合理去配置和管理历史记录，可以让你的 Linux 系统更加健壮和安全。</p><p>现在总结一下 <code>history</code> 命令常用方法</p><ul><li><code>history n</code>：只显示最近的 n 条历史记录</li><li><code>history -c</code>：清除缓存区中的历史记录</li><li><code>history -w</code>：将缓存区的历史记录保存到文件</li><li><code>history -d N</code>：删除第 N 条历史记录<br>几种重复执行命令的方法：<code>!!</code>、<code>!N</code>、<code>!start</code> 等</li></ul><p>交互式历史命令搜索，请使用 Ctrl+R 快捷键</p><p>合适使用几个相关的环境变量，让你的 Linux 系统更安全：</p><ul><li>HISTSIZE：控制缓冲区历史记录的最大个数</li><li>HISTFILESIZE：控制历史记录文件中的最大个数</li><li>HISTIGNORE：设置哪些命令不记录到历史记录</li><li>HISTTIMEFORMAT：设置历史命令显示的时间格式</li><li>HISTCONTROL：扩展的控制选项</li></ul><p>如果在生产环境，这些环境变量需要持久化到配置文件 <code>~/.bash_profile</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ignorespace: 忽略空格开头的命令</span><br><span class="line"># ignoredups: 忽略连续重复命令</span><br><span class="line"># ignoreboth: 表示上述两个参数都设置</span><br><span class="line">export HISTCONTROL=ignoreboth</span><br><span class="line"></span><br><span class="line"># 设置追加而不是覆盖</span><br><span class="line">shopt -s histappend</span><br><span class="line"></span><br><span class="line">export HISTSIZE=1000</span><br><span class="line">export HISTFILESIZE=200000</span><br><span class="line">export HISTTIMEFORMAT=&quot;%F %T &quot;</span><br><span class="line">export HISTIGNORE=&quot;ls:history&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当我们频繁使用 Linux 命令行时，有效地使用历史记录，可以大大提高工作效率。&lt;/p&gt;
&lt;p&gt;在平时 Linux 操作过程中，很多命令是重复的，你一定不希望大量输入重复的命令。如果你是系统管理员，你可能需要对用户操作进行审计，管理好 Linux 命令历史记录显得非常重要。
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.smilexin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IDEA 代码补全操作技巧</title>
    <link href="https://blog.smilexin.cn/2021/05/11/IDEA%20%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7.html"/>
    <id>https://blog.smilexin.cn/2021/05/11/IDEA 代码补全操作技巧.html</id>
    <published>2021-05-10T16:00:00.000Z</published>
    <updated>2021-05-11T10:02:50.304Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA 有个很牛逼的功能，那就是代码补全，极大的方便了开发人员。</p><p>下面是我比较常用的</p><h1 id="var-声明变量"><a href="#var-声明变量" class="headerlink" title="var 声明变量"></a>var 声明变量</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/idea1/var.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="null-判空"><a href="#null-判空" class="headerlink" title="null 判空"></a>null 判空</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/idea1/null.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="nn-判非空"><a href="#nn-判非空" class="headerlink" title="nn 判非空"></a>nn 判非空</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/idea1/nn.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="for-遍历"><a href="#for-遍历" class="headerlink" title="for 遍历"></a>for 遍历</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/idea1/for.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="fori-带索引的遍历"><a href="#fori-带索引的遍历" class="headerlink" title="fori 带索引的遍历"></a>fori 带索引的遍历</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/idea1/fori.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="if-条件判断"><a href="#if-条件判断" class="headerlink" title="if 条件判断"></a>if 条件判断</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/idea1/if.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="cast-强转"><a href="#cast-强转" class="headerlink" title="cast 强转"></a>cast 强转</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/idea1/cast.gif" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IDEA 有个很牛逼的功能，那就是代码补全，极大的方便了开发人员。&lt;/p&gt;
&lt;p&gt;下面是我比较常用的&lt;/p&gt;
&lt;h1 id=&quot;var-声明变量&quot;&gt;&lt;a href=&quot;#var-声明变量&quot; class=&quot;headerlink&quot; title=&quot;var 声明变量&quot;&gt;&lt;/a&gt;var 
      
    
    </summary>
    
    
      <category term="IDEA" scheme="https://blog.smilexin.cn/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置详解</title>
    <link href="https://blog.smilexin.cn/2021/05/11/Nginx%20%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://blog.smilexin.cn/2021/05/11/Nginx 配置详解.html</id>
    <published>2021-05-10T16:00:00.000Z</published>
    <updated>2021-05-11T02:47:50.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx相关地址"><a href="#Nginx相关地址" class="headerlink" title="Nginx相关地址"></a>Nginx相关地址</h1><blockquote><p>源码：<a href="https://trac.nginx.org/nginx/browser" target="_blank" rel="noopener">https://trac.nginx.org/nginx/browser</a><br>官网：<a href="http://www.nginx.org/" target="_blank" rel="noopener">http://www.nginx.org/</a></p></blockquote><h1 id="Nginx常用功能"><a href="#Nginx常用功能" class="headerlink" title="Nginx常用功能"></a>Nginx常用功能</h1><ol><li>Http代理，反向代理：作为web服务器最常用的功能之一，尤其是反向代理。</li></ol><p>这里我给来2张图，对正向代理与反响代理做个诠释，具体细节，大家可以翻阅下资料。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/nginx/1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ol start="2"><li>负载均衡<br>Nginx提供的负载均衡策略有2种：内置策略和扩展策略。内置策略为轮询，加权轮询，Iphash。扩展策略，就天马行空，只有你想不到的没有他做不到的啦，你可以参照所有的负载均衡算法，给他一一找出来做下实现。</li></ol><ul><li>轮询(默认方式)<br>每个请求按时间顺序逐一分配到后端服务器,如果后端服务器down掉,能自动剔除</li><li><p>权重<br>weight和访问比率成正比，用于后端服务器性能不均的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream example1 &#123;</span><br><span class="line">    server 192.168.159.10 weight=10;</span><br><span class="line">    server 192.168.159.11 weight=10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ip_hash<br>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream example2 &#123;</span><br><span class="line">     ip_hash;</span><br><span class="line">     server 192.168.159.10:8080;</span><br><span class="line">     server 192.168.159.11:8080;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>fair(第三方)<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream resinserver&#123;</span><br><span class="line">     server server1;</span><br><span class="line">     server server2;</span><br><span class="line">     fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>web缓存</li></ol><p>Nginx可以对不同的文件做不同的缓存处理，配置灵活，并且支持FastCGI_Cache，主要用于对FastCGI的动态程序进行缓存。配合着第三方的ngx_cache_purge，对制定的URL缓存内容可以的进行增删管理。</p><h1 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h1><ul><li>nginx.conf<br>这个是nginx的主配置文件,nginx启动的时候就是读取这个配置文件。</li><li>conf.d<br>这是一个目录,里面可以写我们自己自定义的配置文件,文件结尾一定是.conf才可以生效(当然也可以通过修改nginx.conf来取消这个限制)</li><li>sites-enabled<br>这里面的配置文件其实就是sites-available里面的配置文件的软连接,但是由于nginx.conf默认包含的是这个文件夹,所以我们在sites-available里面建立了新的站点之后,还要建立个软连接到sites-enabled里面才行</li><li>sites-available<br>这里是我们的虚拟主机的目录，我们在在这里面可以创建多个虚拟主机</li></ul><h1 id="Nginx配置结构"><a href="#Nginx配置结构" class="headerlink" title="Nginx配置结构"></a>Nginx配置结构</h1><p>在 nginx.conf 的注释符号为： #</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...              #全局块</span><br><span class="line"></span><br><span class="line">events &#123;         #events块</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http      #http块</span><br><span class="line">&#123;</span><br><span class="line">    ...   #http全局块</span><br><span class="line">    server        #server块</span><br><span class="line">    &#123; </span><br><span class="line">        ...       #server全局块</span><br><span class="line">        location [PATTERN]   #location块</span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        location [PATTERN] </span><br><span class="line">        &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...     #http全局块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li>events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li>http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li>server块：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li>location块：配置请求的路由，以及各种页面的处理情况。</li></ol><p>下面给大家上一个配置文件，作为示例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">########### 每个指令必须有分号结束。#################</span><br><span class="line">#user administrator administrators;  #配置用户或者组，默认为nobody nobody。</span><br><span class="line">#worker_processes 2;  #允许生成的进程数，默认为1,建议设置同CPU数一致</span><br><span class="line">#pid /nginx/pid/nginx.pid;   #指定nginx进程运行文件存放地址</span><br><span class="line">error_log log/error.log debug;  #制定日志路径，级别。这个设置可以放入全局块，http块，server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class="line">events &#123;</span><br><span class="line">    #accept_mutex on;   #设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class="line">    #multi_accept on;  #设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class="line">    #use epoll;      #事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class="line">    worker_connections  1024;    #最大连接数，默认为512</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;   #文件扩展名与文件类型映射表</span><br><span class="line">    default_type  application/octet-stream; #默认文件类型，默认为text/plain</span><br><span class="line">    #access_log off; #取消服务日志    </span><br><span class="line">    log_format myFormat &apos;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&apos;; #自定义格式</span><br><span class="line">    access_log log/access.log myFormat;  #combined为日志格式的默认值</span><br><span class="line">    sendfile on;   #允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。</span><br><span class="line">    sendfile_max_chunk 100k;  #每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。</span><br><span class="line">    keepalive_timeout 65;  #连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class="line"></span><br><span class="line"># 负载均衡</span><br><span class="line">    upstream myserver &#123;   </span><br><span class="line">      server 127.0.0.1:7878;</span><br><span class="line">  server 127.0.0.1:7879;</span><br><span class="line">      server 192.168.10.121:3333 backup;  #热备</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page 404 https://www.baidu.com; #错误页</span><br><span class="line">    server &#123;</span><br><span class="line">        keepalive_requests 120; #单连接请求上限次数。</span><br><span class="line">        listen       4545;   #监听端口</span><br><span class="line">        server_name  127.0.0.1;   #监听地址,一般为域名    </span><br><span class="line">        location  ~*^.+$ &#123;       #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。</span><br><span class="line">           #root path;  #根目录</span><br><span class="line">           #index vv.txt;  #设置默认页</span><br><span class="line">           proxy_pass  http://myserver;  #请求转向myserver定义的服务器列表</span><br><span class="line">           deny 127.0.0.1;  #拒绝的ip</span><br><span class="line">           allow 172.18.5.54; #允许的ip           </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是nginx的基本配置，需要注意的有以下几点：</p><ol><li>几个常见配置项：</li></ol><ul><li>$remote_addr 与 $http_x_forwarded_for 用以记录客户端的ip地址；</li><li>$remote_user ：用来记录客户端用户名称；</li><li>$time_local ： 用来记录访问时间与时区；</li><li>$request ： 用来记录请求的url与http协议；</li><li>$status ： 用来记录请求状态；成功是200；</li><li>$body_bytes_s ent ：记录发送给客户端文件主体内容大小；</li><li>$http_referer ：用来记录从那个页面链接访问过来的；</li><li>$http_user_agent ：记录客户端浏览器的相关信息；</li></ul><ol start="2"><li>惊群现象：一个网络连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得连接，这样会影响系统性能。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx相关地址&quot;&gt;&lt;a href=&quot;#Nginx相关地址&quot; class=&quot;headerlink&quot; title=&quot;Nginx相关地址&quot;&gt;&lt;/a&gt;Nginx相关地址&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://trac.ngin
      
    
    </summary>
    
    
      <category term="Nginx" scheme="https://blog.smilexin.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>VMware 克隆虚拟机</title>
    <link href="https://blog.smilexin.cn/2021/05/10/VMware%20%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA.html"/>
    <id>https://blog.smilexin.cn/2021/05/10/VMware 克隆虚拟机.html</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2021-05-10T09:53:36.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo hostnamectl set-hostname &lt;newhostname&gt;</span><br></pre></td></tr></table></figure><p>这条命令会删除/etc/hostname文件中的主机名，然后替换为新的主机名。我们还需要更新/etc/hosts文件,追加newhostname的解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 &lt;newhostname&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>/etc/hosts文件是用来将主机名映射为ip地址的文件，也就是域名解析的作用，在之前没有DNS的时候是使用该文件来进行域名和ip地址的映射。</p></blockquote><p>有些同学的etc/hosts文件中包括如下两行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">::1 localhost</span><br></pre></td></tr></table></figure></p><p>127.0.0.1表示ipv4的本地地址</p><p>而::1表示的时ipv6的本地地址，也就是0000:0000:0000:0000:0000:0000:0000:0001</p><h1 id="修改新节点的内网IP"><a href="#修改新节点的内网IP" class="headerlink" title="修改新节点的内网IP"></a>修改新节点的内网IP</h1><ol><li><p>修改网络配置文件更新ip</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure></li><li><p>systemctl restart network 重启network</p></li><li><p>如果不能用systemctl就重启系统reboot</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修改hostname&quot;&gt;&lt;a href=&quot;#修改hostname&quot; class=&quot;headerlink&quot; title=&quot;修改hostname&quot;&gt;&lt;/a&gt;修改hostname&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="VMware" scheme="https://blog.smilexin.cn/tags/VMware/"/>
    
      <category term="虚拟机" scheme="https://blog.smilexin.cn/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker快速搭建代理服务器</title>
    <link href="https://blog.smilexin.cn/2021/05/10/%E4%BD%BF%E7%94%A8Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
    <id>https://blog.smilexin.cn/2021/05/10/使用Docker快速搭建代理服务器.html</id>
    <published>2021-05-09T16:00:00.000Z</published>
    <updated>2021-05-20T07:38:15.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><h2 id="http代理"><a href="#http代理" class="headerlink" title="http代理"></a>http代理</h2><p>当前服务器有个第三方部署的服务只支持内网IP访问,我就需要在内网服务器上搭建一个HTTP代理服务进行访问该服务。</p><p>启动HTTP代理服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name myprivoxy -d -p 1080:8118 splazit/privoxy-alpine</span><br></pre></td></tr></table></figure></p><h2 id="socks5代理"><a href="#socks5代理" class="headerlink" title="socks5代理"></a>socks5代理</h2><p>启动socks5代理服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 1080:1080 nithoalif/microsocks</span><br><span class="line"># 测试</span><br><span class="line">curl --proxy socks5://localhost:1080 www.baidu.com</span><br></pre></td></tr></table></figure></p><h1 id="下面是我在网上找的HTTP代理服务使用方法-还没测试使用-，这里做个记录"><a href="#下面是我在网上找的HTTP代理服务使用方法-还没测试使用-，这里做个记录" class="headerlink" title="下面是我在网上找的HTTP代理服务使用方法(还没测试使用)，这里做个记录"></a>下面是我在网上找的HTTP代理服务使用方法(还没测试使用)，这里做个记录</h1><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line"></span><br><span class="line">EXPOSE 8118</span><br><span class="line"></span><br><span class="line">RUN apk --no-cache --update add privoxy wget ca-certificates bash p7zip &amp;&amp; \</span><br><span class="line">    wget https://s3.amazonaws.com/ab2p/ab2p.all_rus.7z &amp;&amp; \</span><br><span class="line">    mkdir temp &amp;&amp; \</span><br><span class="line">    7za e ab2p.all_rus.7z -y -otemp &amp;&amp; \</span><br><span class="line">    cp temp/ab2p.system.action temp/ab2p.action temp/ab2p.system.filter temp/ab2p.filter /etc/privoxy &amp;&amp; \</span><br><span class="line">    sed -i&apos;&apos; &apos;s/127\.0\.0\.1:8118/0\.0\.0\.0:8118/&apos; /etc/privoxy/config &amp;&amp; \</span><br><span class="line">    sed -i&apos;&apos; &apos;s/enable-edit-actions\ 0/enable-edit-actions\ 1/&apos; /etc/privoxy/config &amp;&amp; \</span><br><span class="line">    sed -i&apos;&apos; &apos;s/#max-client-connections/max-client-connections/&apos; /etc/privoxy/config &amp;&amp; \</span><br><span class="line">    sed -i&apos;&apos; &apos;s/accept-intercepted-requests\ 0/accept-intercepted-requests\ 1/&apos; /etc/privoxy/config &amp;&amp; \    </span><br><span class="line">    sed -i&apos;&apos; &apos;s/http/https/g&apos; /etc/privoxy/ab2p.system.filter &amp;&amp; \</span><br><span class="line">    echo &apos;actionsfile ab2p.system.action&apos; &gt;&gt; /etc/privoxy/config &amp;&amp; \</span><br><span class="line">    echo &apos;actionsfile ab2p.action&apos; &gt;&gt; /etc/privoxy/config &amp;&amp; \</span><br><span class="line">    echo &apos;filterfile ab2p.system.filter&apos; &gt;&gt; /etc/privoxy/config &amp;&amp; \</span><br><span class="line">    echo &apos;filterfile ab2p.filter&apos; &gt;&gt; /etc/privoxy/config &amp;&amp; \</span><br><span class="line">    rm -Rf temp ab2p.all_rus.7z &amp;&amp; \</span><br><span class="line">    apk del bash p7zip</span><br><span class="line">RUN chown privoxy.privoxy /etc/privoxy/*</span><br><span class="line">ENTRYPOINT [&quot;privoxy&quot;]</span><br><span class="line">CMD [&quot;--no-daemon&quot;,&quot;--user&quot;,&quot;privoxy&quot;,&quot;/etc/privoxy/config&quot;]</span><br></pre></td></tr></table></figure><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --restart unless-stopped --name privoxy -p 8118:8118 splazit/privoxy-alpine</span><br></pre></td></tr></table></figure><h2 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -vv https://www.bing.com --proxy localhost:8118</span><br></pre></td></tr></table></figure><h1 id="Win10电脑启用HTTP代理服务"><a href="#Win10电脑启用HTTP代理服务" class="headerlink" title="Win10电脑启用HTTP代理服务"></a>Win10电脑启用HTTP代理服务</h1><p>在本地电脑配置代理服务<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/posts/proxy/w10_http_proxy.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>然后就可以打开浏览器通过内网IP访问该服务了。</p><h1 id="问题处理：Maximum-number-of-open-connections-reached"><a href="#问题处理：Maximum-number-of-open-connections-reached" class="headerlink" title="问题处理：Maximum number of open connections reached."></a>问题处理：Maximum number of open connections reached.</h1><p>错误信息：已达到最大打开连接数。某些时候我们使用代理打开一个网页会出现这个异常提示,是因为网页的资源过多(JS,CSS…),造成代理服务器的连接超过 <code>max-client-connections</code>配置的数值了。这个时候需要修改配置文件 <code>/etc/privoxy/config</code> 改大 <code>max-client-connections</code> 配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#  6.9. max-client-connections</span><br><span class="line">#  ============================</span><br><span class="line">#</span><br><span class="line">#  Specifies:</span><br><span class="line">#</span><br><span class="line">#      Maximum number of client connections that will be served.</span><br><span class="line">#</span><br><span class="line">#  Type of value:</span><br><span class="line">#</span><br><span class="line">#      Positive number.</span><br><span class="line">#</span><br><span class="line">#  Default value:</span><br><span class="line">#</span><br><span class="line">#      128</span><br><span class="line">#</span><br><span class="line">#  Effect if unset:</span><br><span class="line">#</span><br><span class="line">#      Connections are served until a resource limit is reached.</span><br><span class="line">#</span><br><span class="line">#  Notes:</span><br><span class="line">#</span><br><span class="line">#      Privoxy creates one thread (or process) for every incoming</span><br><span class="line">#      client connection that isn&apos;t rejected based on the access</span><br><span class="line">#      control settings.</span><br><span class="line">#</span><br><span class="line">#      If the system is powerful enough, Privoxy can theoretically</span><br><span class="line">#      deal with several hundred (or thousand) connections at the</span><br><span class="line">#      same time, but some operating systems enforce resource limits</span><br><span class="line">#      by shutting down offending processes and their default limits</span><br><span class="line">#      may be below the ones Privoxy would require under heavy load.</span><br><span class="line">#</span><br><span class="line">#      Configuring Privoxy to enforce a connection limit below the</span><br><span class="line">#      thread or process limit used by the operating system makes</span><br><span class="line">#      sure this doesn&apos;t happen. Simply increasing the operating</span><br><span class="line">#      system&apos;s limit would work too, but if Privoxy isn&apos;t the only</span><br><span class="line">#      application running on the system, you may actually want to</span><br><span class="line">#      limit the resources used by Privoxy.</span><br><span class="line">#</span><br><span class="line">#      If Privoxy is only used by a single trusted user, limiting the</span><br><span class="line">#      number of client connections is probably unnecessary. If there</span><br><span class="line">#      are multiple possibly untrusted users you probably still want</span><br><span class="line">#      to additionally use a packet filter to limit the maximal</span><br><span class="line">#      number of incoming connections per client. Otherwise a</span><br><span class="line">#      malicious user could intentionally create a high number of</span><br><span class="line">#      connections to prevent other users from using Privoxy.</span><br><span class="line">#</span><br><span class="line">#      Obviously using this option only makes sense if you choose a</span><br><span class="line">#      limit below the one enforced by the operating system.</span><br><span class="line">#</span><br><span class="line">#      One most POSIX-compliant systems Privoxy can&apos;t properly deal</span><br><span class="line">#      with more than FD_SETSIZE file descriptors at the same time</span><br><span class="line">#      and has to reject connections if the limit is reached. This</span><br><span class="line">#      will likely change in a future version, but currently this</span><br><span class="line">#      limit can&apos;t be increased without recompiling Privoxy with a</span><br><span class="line">#      different FD_SETSIZE limit.</span><br><span class="line">#</span><br><span class="line">#  Example:</span><br><span class="line">#</span><br><span class="line">#      max-client-connections 256</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /opt/myprivoxy/ 为宿主机目录</span><br><span class="line">docker cp myprivoxy:/etc/privoxy/config /opt/myprivoxy/</span><br></pre></td></tr></table></figure><p>编辑配置文件,设置<code>max-client-connections</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /opt/myprivoxy/config</span><br><span class="line">max-client-connections 65535</span><br></pre></td></tr></table></figure></p><p>启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 挂载修改后的config文件启动容器</span><br><span class="line">docker run --name myprivoxy2 -d -p 1080:8118 -v /opt/myprivoxy/config:/etc/privoxy/config splazit/privoxy-alpine</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;快速使用&quot;&gt;&lt;a href=&quot;#快速使用&quot; class=&quot;headerlink&quot; title=&quot;快速使用&quot;&gt;&lt;/a&gt;快速使用&lt;/h1&gt;&lt;h2 id=&quot;http代理&quot;&gt;&lt;a href=&quot;#http代理&quot; class=&quot;headerlink&quot; title=&quot;http代
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://blog.smilexin.cn/tags/Docker/"/>
    
      <category term="Privoxy" scheme="https://blog.smilexin.cn/tags/Privoxy/"/>
    
  </entry>
  
  <entry>
    <title>Linux（Centos版本）快速安装Docker</title>
    <link href="https://blog.smilexin.cn/2021/05/09/Linux%EF%BC%88Centos%E7%89%88%E6%9C%AC%EF%BC%89%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85Docker.html"/>
    <id>https://blog.smilexin.cn/2021/05/09/Linux（Centos版本）快速安装Docker.html</id>
    <published>2021-05-08T16:00:00.000Z</published>
    <updated>2021-05-09T02:18:02.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用脚本安装-Docker"><a href="#使用脚本安装-Docker" class="headerlink" title="使用脚本安装 Docker"></a>使用脚本安装 Docker</h1><ol><li>使用 sudo 或 root 权限登录 Centos。</li><li><p>确保 yum 包更新到最新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y update</span><br></pre></td></tr></table></figure></li><li><p>执行 Docker 安装脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh // 执行这个脚本会添加 docker.repo 源并安装 Docker。</span><br></pre></td></tr></table></figure></li></ol><h1 id="启动-Docker-进程。"><a href="#启动-Docker-进程。" class="headerlink" title="启动 Docker 进程。"></a>启动 Docker 进程。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start 或 systemctl start docker</span><br></pre></td></tr></table></figure><h1 id="验证Docker是否安装成功"><a href="#验证Docker是否安装成功" class="headerlink" title="验证Docker是否安装成功"></a>验证Docker是否安装成功</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 20.10.6, build 370c289</span><br></pre></td></tr></table></figure><h1 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h1><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="noopener">http://hub-mirror.c.163.com。</a></p><p>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。</p><p>请在该配置文件中加入（没有该文件的话，请先建一个）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用脚本安装-Docker&quot;&gt;&lt;a href=&quot;#使用脚本安装-Docker&quot; class=&quot;headerlink&quot; title=&quot;使用脚本安装 Docker&quot;&gt;&lt;/a&gt;使用脚本安装 Docker&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;使用 sudo 或 root 权限登录 
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://blog.smilexin.cn/tags/Docker/"/>
    
      <category term="Linux" scheme="https://blog.smilexin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker 常用命令</title>
    <link href="https://blog.smilexin.cn/2021/05/08/Docker%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>https://blog.smilexin.cn/2021/05/08/Docker 常用命令.html</id>
    <published>2021-05-07T16:00:00.000Z</published>
    <updated>2021-05-09T02:29:17.238Z</updated>
    
    <content type="html"><![CDATA[<p>Docker常用命令记录，方便查询</p><h1 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h1><blockquote><p>docker search [OPTIONS] 镜像名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查找stars数不低于10的centos镜像</span><br><span class="line">docker search -f stars=10 centos</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地的镜像</span><br><span class="line">$ docker images</span><br><span class="line"># 如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</span><br><span class="line">$ docker pull ubuntu</span><br></pre></td></tr></table></figure><h1 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps // 查看Docker正在运行的容器</span><br><span class="line">docker ps -a // 列出Docker所有容器</span><br><span class="line">docker ps -l // 列出最新创建的一个容器</span><br><span class="line">docker ps [-a][-l]</span><br><span class="line">docker inspect 容器名字|容器ID // 查看指定容器信息</span><br></pre></td></tr></table></figure><h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><ul><li>docker run:使用镜像启动对应的容器</li></ul><p>docker run 参数说明：</p><ul><li>-d :代表后台运行容器，返回容器ID</li><li>–name: 自定义容器的名称，不加这命令docker会随便给一个名给你，所以建议打上这命令</li><li>-p :代表映射的端口 本地端口:容器端口</li><li>-i: 以交互模式运行容器，通常与 -t 同时使用；</li><li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li><li>-P: 随机端口映射，容器内部端口随机映射到主机的高端口</li><li><p>–volume , -v: 挂载一个卷到容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 启动交互式容器</span><br><span class="line">docker run -it IMAGE_NAME /bin/bash</span><br><span class="line"># 使用nginx镜像启动一个容器，容器名称设置为mynginx</span><br><span class="line">docker run --name=mynginx -it nginx /bin/bash</span><br><span class="line"># 在大部分的场景下，我们希望 docker 的服务是在后台运行的，可以使用 -d 指定容器在后台运行。</span><br><span class="line"># 注：加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 docker exec</span><br><span class="line">docker run --name=mynginx -d nginx</span><br></pre></td></tr></table></figure></li><li><p>docker start:启动停止的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 启动一个容器名为nginx-1的容器</span><br><span class="line">docker start nginx-1</span><br><span class="line"># 启动两个容器，分别为容器名为nginx-1、容器ID为356466a99c7f的两个容器</span><br><span class="line">docker start nginx-1 356466a99c7f</span><br></pre></td></tr></table></figure></li></ul><h1 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 优雅的停止容器</span><br><span class="line">docker stop 容器ID或容器名</span><br><span class="line"># 直接关闭容器</span><br><span class="line">docker kill 容器ID或容器名</span><br><span class="line"># 参数 -t：关闭容器的限时，如果超时未能关闭则用kill强制关闭，默认值10s，这个时间用于容器的自己保存状态</span><br><span class="line">docker stop -t 容器ID或容器名</span><br><span class="line">docker stop -t=60 容器ID或容器名</span><br></pre></td></tr></table></figure><h1 id="映射端口"><a href="#映射端口" class="headerlink" title="映射端口"></a>映射端口</h1><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P（大写） 或 -p （小写） 参数来指定端口映射。<br>（1）当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。<br>（2）-p（小写）则可以指定要映射的IP和端口，但是在一个指定端口上只可以绑定一个容器。-p 标记可以多次使用来绑定多个端口。<br>支持的格式有 hostPort:containerPort、ip:hostPort:containerPort、 ip::containerPort。</p><p>hostPort:containerPort（映射所有接口地址）<br>将本地的 5000 端口映射到容器的 5000 端口，可以执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure></p><p>ip:hostPort:containerPort （映射指定地址的指定端口）<br>指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure></p><p>ip::containerPort （映射指定地址的任意端口）<br>绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure></p><p>还可以使用 udp 标记来指定 udp 端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 参数 -p 是指把镜像内的12345端口映射到宿主机的80端口</span><br><span class="line">$ docker run -d -p 80:12345 nginx</span><br><span class="line"># 不指定宿主机端口，随机映射出来</span><br><span class="line"># 查看容器c5b暴露的端口,27017是容器端口,37017是宿主机端口</span><br><span class="line">$ docker port c5b</span><br><span class="line">27017tcp -&gt; 0.0.0.0:37017</span><br><span class="line"># -p 标记可以多次使用来绑定多个端口</span><br><span class="line">$ docker run -d -p 5000:5000 -p 3000:80 nginx</span><br></pre></td></tr></table></figure><h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><p>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p><ul><li>docker exec</li><li>docker attach<br>使用attach的话，如果从这个容器退出，会导致容器的停止。推荐使用exec<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 进入id为243c32535da7的这个容器</span><br><span class="line">docker exec -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure></li></ul><h1 id="提交容器"><a href="#提交容器" class="headerlink" title="提交容器"></a>提交容器</h1><p>在本地创建一个容器后，可以依据这个容器创建本地镜像，并可把这个镜像推送到Docker hub中，以便在网络上下载使用。<br>docker commit:从容器创建一个新的镜像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"># 创建myubuntu:v1镜像</span><br><span class="line">$ docker commit -a &quot;hejx&quot; -m &quot;this is test&quot; 651a8541a47d myubuntu:v1</span><br></pre></td></tr></table></figure></p><ul><li>-a :提交的镜像作者；</li><li>-c :使用Dockerfile指令来创建镜像；</li><li>-m :提交时的说明文字；</li><li>-p :在commit时，将容器暂停。</li></ul><h1 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 推送镜像到docker hub仓库</span><br><span class="line">$ docker push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">首先是登录docker hub （用户名：hejx    密码:*******）</span><br><span class="line">[root@docker-test1 ~]# docker login</span><br><span class="line">Login with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.</span><br><span class="line">Username (hejx): hejx</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br><span class="line"> </span><br><span class="line">[root@docker-test1 ~]# docker push hejx/myubuntu:v1</span><br><span class="line">The push refers to a repository [docker.io/hejx/myubuntu]</span><br><span class="line">An image does not exist locally with the tag: docker.io/hejx/myubuntu</span><br><span class="line"> </span><br><span class="line">这里需要将ubuntu:v1镜像改名，在名称前加上自己的docker hub的Docker ID，即hejx</span><br><span class="line"> </span><br><span class="line">[root@docker-test1 ~]# docker tag 6ce4aedd12cd hejx/myubuntu:v1</span><br><span class="line">[root@docker-test1 ~]# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">myubuntu             v1                  6ce4aedd12cd        6 minutes ago       84.1 MB</span><br><span class="line">hejx/myubuntu   v1                  6ce4aedd12cd        6 minutes ago       84.1 MB</span><br><span class="line">docker.io/ubuntu     16.04               7aa3602ab41e        5 weeks ago         115 MB</span><br><span class="line"> </span><br><span class="line">再次进行推送（注意：下面的v1的tag标签可以不打，默认是latest）。推送操作时间稍微会有一点长，耐心等待～</span><br><span class="line">[root@docker-test1 ~]# docker push hejx/myubuntu:v1           </span><br><span class="line">The push refers to a repository [docker.io/hejx/myubuntu]</span><br><span class="line">b5948ba9486d: Pushed</span><br><span class="line">8d7ea83e3c62: Mounted from library/ubuntu</span><br><span class="line">6a061ee02432: Mounted from library/ubuntu</span><br><span class="line">f73b2816c52a: Mounted from library/ubuntu</span><br><span class="line">6267b420796f: Mounted from library/ubuntu</span><br><span class="line">a30b835850bf: Mounted from library/ubuntu</span><br><span class="line">v1: digest: sha256:e9cd9075d262848a307c92751e1a5890d883b814a31abd118161442461a1ca2d size: 1564</span><br><span class="line"> </span><br><span class="line">最后登录自己的Docker Hub，即https://hub.docker.com/</span><br><span class="line">登录后，在Repositories里面就可以看到自己在上面推送的镜像hejx/myubuntu:v1了，这是个对外的镜像，可以在网络上下载。</span><br><span class="line">在Docker hub上可以看到这个镜像的下载命令（注意下载时跟上tag标签，如果是latest的默认tag可以不跟）</span><br><span class="line">也可以直接在Docker hub上删除这个镜像（Repositories-镜像-Settings-delete）</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">比如在另一台服务器上下载这个镜像</span><br><span class="line">[root@kevin-test ~]# docker pull hejx/myubuntu</span><br><span class="line">Pulling repository hejx/myubuntu</span><br><span class="line">Repository not found</span><br><span class="line"> </span><br><span class="line">需要跟上tag标签</span><br><span class="line">[root@kevin-test ~]# docker pull hejx/myubuntu:v1</span><br><span class="line">v1: Pulling from hejx/myubuntu</span><br><span class="line">68e2a091ef24: Pull complete</span><br><span class="line">c393a882769e: Pull complete</span><br><span class="line">Digest: sha256:845fa3dcc9d0de1b9c701e1009918995da35a29012015f6c297a05edc489e018</span><br><span class="line">Status: Downloaded newer image for hejx/myubuntu:v1</span><br><span class="line">[root@kevin-test ~]# docker  images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">hejx/myubuntu   v1                  c393a882769e        12 minutes ago      84.11 MB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Docker常用命令记录，方便查询&lt;/p&gt;
&lt;h1 id=&quot;获取镜像&quot;&gt;&lt;a href=&quot;#获取镜像&quot; class=&quot;headerlink&quot; title=&quot;获取镜像&quot;&gt;&lt;/a&gt;获取镜像&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;docker search [OPTIONS] 
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://blog.smilexin.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux 指定目录扩容</title>
    <link href="https://blog.smilexin.cn/2021/05/08/Linux%20%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%E6%89%A9%E5%AE%B9.html"/>
    <id>https://blog.smilexin.cn/2021/05/08/Linux 指定目录扩容.html</id>
    <published>2021-05-07T16:00:00.000Z</published>
    <updated>2021-05-09T02:21:33.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>在阿里云上面使用自定义的镜像可能会导致系统盘无法扩容，这个时候就需要<a href="https://help.aliyun.com/document_detail/25446.html" target="_blank" rel="noopener">挂载数据盘</a>进行弯道扩容。</p><h1 id="挂载新硬盘到home目录"><a href="#挂载新硬盘到home目录" class="headerlink" title="挂载新硬盘到home目录"></a>挂载新硬盘到home目录</h1><p>挂载到home目录有两种情况：一种home目录是新的目录里面没有数据。第二种是home目录已经有了数据。</p><p>第一种很好处理，直接使用mount /dev/vdb1 /home命令就可以完成挂载,后面的就不用看了。<br>第二种就比较麻烦，因为如果home目录有内容直接按第一种方法挂载会发现挂载之后home目录下的东西都不见了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果已经已经使用了直接挂载的方法造成home目录下的文件丢失，不要慌直接再将盘卸载掉（umount /dev/vdb1）就可以，卸载完文件就会恢复了。</span><br></pre></td></tr></table></figure></p><p>下面主要讲一下第二种方法来挂载到home目录</p><p>使用mkdir transfer创建一个中转文件夹</p><p>使用mount /dev/vdb1 /transfer 将新硬盘挂载到transfer上</p><p>使用 cp -R /home/* /transfer 将home目录下的所有文件复制到中转文件夹</p><p>rm -rf /home/* 删除原硬盘上的home文件夹，为原硬盘腾出空间(可选项,可不删除)</p><p>mount /dev/sdb1 /home接着讲硬盘再挂载到home文件夹</p><p>如果挂载时出现mount: you must specify the filesystem type错误这是因为没有设置文件系统格式，可使用-t参数设置文件系统格式 mount -t ext3 /dev/sdb1 /home<br>df -h 查看硬盘挂载情况，/dev/sdb1 如果现实了挂载到transfer 和home说明都挂载成功</p><p>[root@iZj6capfjz1mgt4s5ab7e6Z /]# df -h<br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/vda1        40G   24G   14G  63% /<br>tmpfs           3.9G     0  3.9G   0% /dev/shm<br>/dev/vdb1        40G   13G   25G  34% /transfer<br>/dev/vdb1        40G   13G   25G  34% /home<br>卸载transfer上的挂载 umount /transfer(如无法卸载 可使用umount -fl /transfer强制卸载)</p><p>最后删除transfer文件夹rm -rf transfer</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h1&gt;&lt;p&gt;在阿里云上面使用自定义的镜像可能会导致系统盘无法扩容，这个时候就需要&lt;a href=&quot;https://help.aliyun.com/doc
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.smilexin.cn/tags/Linux/"/>
    
      <category term="阿里云" scheme="https://blog.smilexin.cn/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用命令</title>
    <link href="https://blog.smilexin.cn/2021/05/07/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <id>https://blog.smilexin.cn/2021/05/07/Linux 常用命令.html</id>
    <published>2021-05-06T16:00:00.000Z</published>
    <updated>2021-05-07T03:48:07.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h1><p>这是linux中一个非常重要命令。它的功能是为某一个文件在另外一个位置建立一个同步的链接，当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。类似于windows里的快捷方式。</p><h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数][源文件或目录][目标文件或目录]</span><br></pre></td></tr></table></figure><h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-b 删除，覆盖以前建立的链接</span><br><span class="line">-d 允许超级用户制作目录的硬链接</span><br><span class="line">-f 强制执行</span><br><span class="line">-i 交互模式，文件存在则提示用户是否覆盖</span><br><span class="line">-n 把符号链接视为一般目录</span><br><span class="line">-s 软链接(符号链接)</span><br><span class="line">-v 显示详细的处理过程</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>给文件创建软链接，为log2013.log文件创建软链接link2013，如果log2013.log丢失，link2013将失效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意建立软连接最好使用文件的绝对路径</span><br><span class="line">ln -s /opt/log2013.log /opt/link2013</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ln&quot;&gt;&lt;a href=&quot;#ln&quot; class=&quot;headerlink&quot; title=&quot;ln&quot;&gt;&lt;/a&gt;ln&lt;/h1&gt;&lt;p&gt;这是linux中一个非常重要命令。它的功能是为某一个文件在另外一个位置建立一个同步的链接，当我们需要在不同的目录，用到相同的文件时，我们不需
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://blog.smilexin.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker 部署MongoDB</title>
    <link href="https://blog.smilexin.cn/2020/04/17/Docker%20%E9%83%A8%E7%BD%B2MongoDB.html"/>
    <id>https://blog.smilexin.cn/2020/04/17/Docker 部署MongoDB.html</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2021-04-30T02:44:33.305Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 是一款较为常用的NOSQL 数据库，结合 Docker 使用，能实现轻松配置部署、迁移，本文以下为简要介绍如何在 Docker 中部署并使用 MongoDB</p><h1 id="MongoDB-Docker-镜像安装"><a href="#MongoDB-Docker-镜像安装" class="headerlink" title="MongoDB Docker 镜像安装"></a>MongoDB Docker 镜像安装</h1><p>MongoDB 提供官方镜像，下载安装镜像方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure></p><p>以上命令为安装 MongoDB 最新版本的镜像。(需配置国内的镜像源)</p><h1 id="MongoDB-Docker-容器创建"><a href="#MongoDB-Docker-容器创建" class="headerlink" title="MongoDB Docker 容器创建"></a>MongoDB Docker 容器创建</h1><p>MongoDB Docker 容器创建主要关心的就是数据文件的存储问题，这个可以使用容器的 volume 功能来解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 17017:27017 -v &lt;LocalDirectoryPath&gt;:/data/db --name mongodb -d mongo --auth</span><br></pre></td></tr></table></figure><p>在上面的命令中，几个命令参数的详细解释如下：<br>-p 17017:27017 容器内部服务端口为27017, 映射到主机的17017端口<br>-v 为设置容器的挂载目录，这里是将<localdirectorypath>即本机中的目录挂载到容器中的/data/db中，作为 mongodb 的存储目录<br>–name 为设置该容器的名称为 mongodb<br>-d 设置容器以守护进程方式运行<br>–auth 开启权限验证</localdirectorypath></p><h1 id="配置容器"><a href="#配置容器" class="headerlink" title="配置容器"></a>配置容器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 进入容器</span><br><span class="line">docker exec -it mongodb /bin/bash</span><br><span class="line"># 安装vim</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line"># 修改 mongo 配置文件</span><br><span class="line">vim /etc/mongod.conf.orig</span><br></pre></td></tr></table></figure><p>将其中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindIp: 127.0.0.1</span><br></pre></td></tr></table></figure></p><p>注释掉 # bindIp: 127.0.0.1<br>或者改成 bindIp: 0.0.0.0<br>即可开启远程连接</p><h1 id="MongoDB权限配置"><a href="#MongoDB权限配置" class="headerlink" title="MongoDB权限配置"></a>MongoDB权限配置</h1><p>创建超级管理员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: &apos;admin&apos;, pwd: &apos;adminPwd&apos;, roles: [ &quot;root&quot; ] &#125;);</span><br></pre></td></tr></table></figure><h2 id="MongoDB-内置角色"><a href="#MongoDB-内置角色" class="headerlink" title="MongoDB 内置角色"></a>MongoDB 内置角色</h2><p>root    超级管理员<br>readAnyDatabase    任何数据库的只读权限<br>userAdminAnyDatabase    任何数据库的读写权限<br>userAdminAnyDatabase    任何数据库用户的管理权限<br>dbAdminAnyDatabase    任何数据库的管理权限</p><h1 id="开关MongoDB"><a href="#开关MongoDB" class="headerlink" title="开关MongoDB"></a>开关MongoDB</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有在运行的容器信息</span><br><span class="line">docker ps</span><br><span class="line"># 启动 mongodb 容器</span><br><span class="line">docker start mongodb</span><br><span class="line"># 关闭 mongodb 容器</span><br><span class="line">docker stop mongodb</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这样我们就可以愉快的使用Docker运行MongoDB了</p><p>MongoDB Address: localhost:17017</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MongoDB 是一款较为常用的NOSQL 数据库，结合 Docker 使用，能实现轻松配置部署、迁移，本文以下为简要介绍如何在 Docker 中部署并使用 MongoDB&lt;/p&gt;
&lt;h1 id=&quot;MongoDB-Docker-镜像安装&quot;&gt;&lt;a href=&quot;#MongoDB
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://blog.smilexin.cn/tags/Docker/"/>
    
      <category term="MongoDB" scheme="https://blog.smilexin.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Golang 环境安装</title>
    <link href="https://blog.smilexin.cn/2020/03/29/Golang%20%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85.html"/>
    <id>https://blog.smilexin.cn/2020/03/29/Golang 环境安装.html</id>
    <published>2020-03-28T16:00:00.000Z</published>
    <updated>2021-04-30T02:44:33.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言的安装"><a href="#Go语言的安装" class="headerlink" title="Go语言的安装"></a>Go语言的安装</h1><p>可以在Go语言中文网进行下载对应系统版本的Go语言: <a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a></p><p>我这里下载的是 1.14.1 的版本</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用go module管理依赖</span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line"># 配置国内镜像</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br><span class="line"># 安装goimports,go imports包的引入可以让代码书写变得更加快捷</span><br><span class="line">go get -v golang.org/x/tools/cmd/goimports</span><br></pre></td></tr></table></figure><h1 id="GoLand配置"><a href="#GoLand配置" class="headerlink" title="GoLand配置"></a>GoLand配置</h1><p>主要配置File Watchers插件，使用goimports，让写代码更加舒服。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Go语言的安装&quot;&gt;&lt;a href=&quot;#Go语言的安装&quot; class=&quot;headerlink&quot; title=&quot;Go语言的安装&quot;&gt;&lt;/a&gt;Go语言的安装&lt;/h1&gt;&lt;p&gt;可以在Go语言中文网进行下载对应系统版本的Go语言: &lt;a href=&quot;https://studyg
      
    
    </summary>
    
    
      <category term="Golang" scheme="https://blog.smilexin.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ的消息重试机制</title>
    <link href="https://blog.smilexin.cn/2018/09/01/ActiveMQ_%E6%B6%88%E6%81%AF%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6.html"/>
    <id>https://blog.smilexin.cn/2018/09/01/ActiveMQ_消息重试机制.html</id>
    <published>2018-08-31T16:00:00.000Z</published>
    <updated>2021-04-30T02:44:33.304Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消费端处理失败时的消息重发机制"><a href="#消费端处理失败时的消息重发机制" class="headerlink" title="消费端处理失败时的消息重发机制"></a>消费端处理失败时的消息重发机制</h1><ol><li>处理失败 指的是MessageListener的onMessage方法里抛出RuntimeException。</li><li>Message头里有两个相关字段：Redelivered默认为false，redeliveryCounter默认为0。</li><li>消息先由broker发送给consumer，consumer调用listener，如果处理失败，本地redeliveryCounter++，给broker一个特定应答，broker端的message里redeliveryCounter++，延迟一点时间继续调用，默认1s。超过6次，则给broker另一个特定应答，broker就直接发送消息到DLQ。</li><li>如果失败2次，consumer重启，则broker再推过来的消息里，redeliveryCounter=2，本地只能再重试4次即会进入DLQ。</li><li>重试的特定应答发送到broker，broker即会在内存将消息的redelivered设置为true，redeliveryCounter++，但是这两个字段都没有持久化，即没有修改存储中的消息记录。所以broker重启时这两个字段会被重置为默认值。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消费端处理失败时的消息重发机制&quot;&gt;&lt;a href=&quot;#消费端处理失败时的消息重发机制&quot; class=&quot;headerlink&quot; title=&quot;消费端处理失败时的消息重发机制&quot;&gt;&lt;/a&gt;消费端处理失败时的消息重发机制&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;处理失败 指的是Mess
      
    
    </summary>
    
    
      <category term="ActiveMQ" scheme="https://blog.smilexin.cn/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 配置加密</title>
    <link href="https://blog.smilexin.cn/2018/08/17/SpringBoot%20%E9%85%8D%E7%BD%AE%E5%8A%A0%E5%AF%86.html"/>
    <id>https://blog.smilexin.cn/2018/08/17/SpringBoot 配置加密.html</id>
    <published>2018-08-16T16:00:00.000Z</published>
    <updated>2021-04-30T02:44:33.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>实际项目开发过程中，我们的应用程序都有很多的配置文件（例如properties或者yml文件等），我们时常会遇到需要对配置文件敏感字段的参数内容进行加密处理(比如数据库连接密码、与第三方的通信密钥等)。</p><h1 id="传统Spring解析配置文件"><a href="#传统Spring解析配置文件" class="headerlink" title="传统Spring解析配置文件"></a>传统Spring解析配置文件</h1><p>传统Spring解析配置文件可以继承PropertyPlaceholderConfigurer类并重写其converProperty方法，在该方法内一般需要做两步处理：</p><ol><li>根据参数名propertyName或者根据参数值propertyValue判断当前是否需要进行内容解密（判断是否需要进行解密操作）</li><li>如果需要解密，根据系统设计调用解密处理逻辑，然后调用父级converProperty方法</li></ol><p>按照上面的思路，我们先实现自己的PropertyPlaceholderConfigurer子类，假如当前我们的需求是要将test.content参数值后面追加内容“《我是后加的内容》”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class MyPropertyPlaceholderConfigurer extends PropertyPlaceholderConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected String convertProperty(String propertyName, String propertyValue) &#123;</span><br><span class="line">        //这里做对属性的内容的加解密等操作</span><br><span class="line">        if (propertyName.equalsIgnoreCase(&quot;test.content&quot;)) &#123;</span><br><span class="line">            log.info(&quot;当前即将过滤的内容[&quot; + propertyName + &quot;]=[&quot; + propertyValue + &quot;]&quot;);</span><br><span class="line">            propertyValue = propertyValue + &quot;《我是后加的内容》&quot;;</span><br><span class="line">        &#125; else if (propertyName.equalsIgnoreCase(&quot;spring.datasource.password&quot;)) &#123;</span><br><span class="line">            propertyValue = propertyValue.replace(&quot;abc&quot;, &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return super.convertProperty(propertyName, propertyValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，我们要告诉spring使用自定义的PropertyPlaceholderConfigurer，如果我们使用xml方式配置，则代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;propertyConfigurer&quot; class=&quot;com.spring.boot.test.util.MyPropertPlaceholderConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;locations&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">        &lt;value&gt;classpath:application.poperties&lt;/value&gt;</span><br><span class="line">        &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p><p>如果采用javaconfig方式时代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public PropertyPlaceholderConfigurer propertyPlaceholderConfigurer()&#123;</span><br><span class="line">    PropertyPlaceholderConfigurer placeholderConfigurer=new MyPropertyPlaceholderConfigurer();</span><br><span class="line">    PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();</span><br><span class="line">    Resource resource = resolver.getResource(&quot;classpath:application.properties&quot;);</span><br><span class="line">    placeholderConfigurer.setLocation(resource);</span><br><span class="line">    return placeholderConfigurer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的步骤，我们可以在程序的TestService中使用自动注入或者Spring表达式@Value(“$(参数名)”)获取到的内容就是我们解密之后的内容。启动程序后可以看到日志内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.s.b.t.u.MyPropertyPlaceholderConfigurer[16] - 当前即将过滤的内容[test.content]=[测试内容]</span><br><span class="line">c.s.b.t.s.TestService[24] - 当前拿到的testContent=测试内容《我是后加的内容》</span><br></pre></td></tr></table></figure></p><p>遗憾的时，上述方式存在两个缺点：</p><blockquote><ol><li>目前只支持properties配置文件，当我们使用yml文件后就不生效了，运行会报文件格式异常，如果要生效，必须复写底层的loadProperties方法分别对不同格式的文件进行解析。但是这样可能会麻烦的多。</li><li>当我们使用spring boot后，对数据库相关配置参数解析后，数据库自动初始化装配无法成功，即数据库会在PropertyPlaceholderConfigurer类之前初始化，如果加密内容正好是数据库连接密码，那么程序启动后会因为数据库无法连接而报错，程序自动挂断。错误内容：Failed to initialize pool: Access denied for user ‘root‘@’localhost’ (using password: YES)</li></ol></blockquote><p>面对以上问题，直接通过修改PropertyPlaceholderConfigurer解决的路子我并没有去测试，不过接下来我介绍另外一种方式解决这个问题，那就是spring boot集成jasypt框架实现对配置文件的参数内容加解密。</p><h1 id="使用jasypt进行配置文件的加解密（推荐）"><a href="#使用jasypt进行配置文件的加解密（推荐）" class="headerlink" title="使用jasypt进行配置文件的加解密（推荐）"></a>使用jasypt进行配置文件的加解密（推荐）</h1><p>Jasypt是一个优秀的加密库，支持密码、Digest认证、文本、对象加密，此外密码加密复合RFC2307标准。<a href="http://www.jasypt.org/" target="_blank" rel="noopener">官方地址</a><br><a href="https://github.com/ulisesbocchio/jasypt-spring-boot" target="_blank" rel="noopener">jasypt-spring-boot</a>，集成Spring Boot，在程序引导时对属性进行解密。<br>该工具包使用jasypt框架来处理properties和yml配置文件参数内容的加解密操作，该工具已经发布到了中央仓库供大家使用。而且文档信息非常详细。下面我简单说一下该工具的优势。</p><ol><li>该工具支持注解方式开启jasypt功能，以及注解方式引入一个或多个需要处理的配置文件。</li><li>该工具同时支持properties与yml文件的解析处理。</li><li>该工具支持自定义加解密类型和复写加解密方法。</li></ol><p>使用jasypt框架默认的加密方式存在一定的风险，那就是程序配置文件中，存在解密密文的密码。因为PBEWithMD5AndDES算法到处都可以找到实现。如果拿到了数据库密文和算法的密码，那么很容易解析出连接数据库的密码。一般严谨的做法是不会将密文信息与解密工具放在一起，避免程序被获取后，加密算法和数据库密码密文以及解密密码都同时被泄露。我们可以使用自定义的解密方案,将密钥信息同应用程序分离,增加安全性。</p><p>为了方便演示,我这里就直接把秘钥信息写在程序里面了</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="引入工具包"><a href="#引入工具包" class="headerlink" title="引入工具包"></a>引入工具包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为我这里引用的是jasypt-spring-boot-starter,所以它是引入后自动开启的,并不需要使用注解@EnableEncryptableProperties提示启动</p><h3 id="实现自定义加解密规则"><a href="#实现自定义加解密规则" class="headerlink" title="实现自定义加解密规则"></a>实现自定义加解密规则</h3><p>MyEncryptablePropertyResolver<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import com.*.util.encdec.RSAUtil;</span><br><span class="line">import com.ulisesbocchio.jasyptspringboot.EncryptablePropertyResolver;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by hejx on 2018/8/11.</span><br><span class="line"> */</span><br><span class="line">public class MyEncryptablePropertyResolver implements EncryptablePropertyResolver &#123;</span><br><span class="line"></span><br><span class="line">    /** 需要解密的标识 **/</span><br><span class="line">    private final String cipher = &quot;ENC@&quot;;</span><br><span class="line"></span><br><span class="line">    private final String PRIVATE_KEY = &quot;私钥&quot;;</span><br><span class="line">    private final String PUBLIC_KEY = &quot;公钥&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String resolvePropertyValue(String value) &#123;</span><br><span class="line">        if (value != null &amp;&amp; value.startsWith(cipher)) &#123;</span><br><span class="line">            value = value.substring(cipher.length());</span><br><span class="line">            // System.out.println(&quot;decrypt configure:&quot;+ value);</span><br><span class="line">            return decrypt(value);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加密配置文件</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public final String encrypt(String data)&#123;</span><br><span class="line">        return RSAUtil.encryptByPublicKey(data, PUBLIC_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 解密配置文件</span><br><span class="line">     * @param data</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public final String decrypt(String data)&#123;</span><br><span class="line">        return RSAUtil.decryptByPrivateKey(data, PRIVATE_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        String username = encrypt(&quot;帐号&quot;);</span><br><span class="line">//        String password = encrypt(&quot;密码&quot;);</span><br><span class="line">//        System.out.println(&quot;username:&quot;+username);</span><br><span class="line">//        System.out.println(&quot;password:&quot;+password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注入自定义的解密规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class BaseBeanConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Bean(name=&quot;encryptablePropertyResolver&quot;)</span><br><span class="line">    public EncryptablePropertyResolver encryptablePropertyResolver() &#123;</span><br><span class="line">        return new MyEncryptablePropertyResolver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 密文规则: ENC@ + 密文信息</span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.datasource.url=ENC@datasourceUrl</span><br><span class="line">spring.datasource.username=ENC@djiwoqjdojqwodihdcdjfjf</span><br><span class="line">spring.datasource.password=ENC@密文jdsajoidwjqonkjsadfjifjwf</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>大功告成,自己去试试吧!</p><h1 id="自定义解密逻辑"><a href="#自定义解密逻辑" class="headerlink" title="自定义解密逻辑"></a>自定义解密逻辑</h1><p>这里记录一下我的小思路,大家可以根据项目具体情况选择使用</p><ul><li>采用比较安全的RSA加密算法</li><li>构建时、运行时传入密钥，在加载属性前进行解密</li><li>开发环境可以将密钥放置在代码中，测试、灰度、生产等环境放置在构建脚本或者启动脚本中</li><li>提供专门的程序进行密钥的管理和配置的加解密操作（接口）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;实际项目开发过程中，我们的应用程序都有很多的配置文件（例如properties或者yml文件等），我们时常会遇到需要对配置文件敏感字段的参数
      
    
    </summary>
    
    
      <category term="网络安全" scheme="https://blog.smilexin.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="SpringBoot" scheme="https://blog.smilexin.cn/tags/SpringBoot/"/>
    
      <category term="jasypt" scheme="https://blog.smilexin.cn/tags/jasypt/"/>
    
      <category term="加密" scheme="https://blog.smilexin.cn/tags/%E5%8A%A0%E5%AF%86/"/>
    
      <category term="配置" scheme="https://blog.smilexin.cn/tags/%E9%85%8D%E7%BD%AE/"/>
    
      <category term="配置文件加解密" scheme="https://blog.smilexin.cn/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>layui 表单数据回显问题处理</title>
    <link href="https://blog.smilexin.cn/2018/08/16/layui%20%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86.html"/>
    <id>https://blog.smilexin.cn/2018/08/16/layui 表单数据回显问题处理.html</id>
    <published>2018-08-15T16:00:00.000Z</published>
    <updated>2021-04-30T02:44:33.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>后台编辑页面的数据回显,时好时坏!（多发生于单选框）</p><p>尝试使用setTimeout进行延时填充数据,效果还是时好时坏,并不能有效解决问题!</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;layui-form-item&quot; pane=&quot;&quot;&gt;</span><br><span class="line">&lt;label class=&quot;layui-form-label&quot;&gt;议价规则&lt;/label&gt;</span><br><span class="line">&lt;div class=&quot;layui-input-block&quot;&gt;</span><br><span class="line">&lt;input lay-filter=&quot;is_bargain&quot; ng-model=&quot;entity.is_bargain&quot; type=&quot;radio&quot; name=&quot;is_bargain&quot; value=&quot;0&quot; title=&quot;不支持议价&quot;&gt;</span><br><span class="line">&lt;input lay-filter=&quot;is_bargain&quot; ng-model=&quot;entity.is_bargain&quot; type=&quot;radio&quot; name=&quot;is_bargain&quot; value=&quot;1&quot; title=&quot;支持议价&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 我这里还做了延时装载,效果不理想</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">UE.getEditor(&apos;editor&apos;).setContent($scope.entity.product_content);</span><br><span class="line">layui.use(&apos;form&apos;, function()&#123;</span><br><span class="line">var form = layui.form;</span><br><span class="line">form.val(&apos;inputForm&apos;, &#123;</span><br><span class="line">&quot;is_bargain&quot;: $scope.entity.is_bargain,</span><br><span class="line">&quot;is_advance&quot;: $scope.entity.is_advance,</span><br><span class="line">&quot;freight_type&quot;: $scope.entity.freight_type,</span><br><span class="line">&quot;product_state&quot;: $scope.entity.product_state,</span><br><span class="line">&quot;product_unit&quot;: $scope.entity.product_unit</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,500);</span><br></pre></td></tr></table></figure><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>因为是页面异步加载数据,所以可能存在加载数据的时候,layui组件没有完全加载完毕的情况。所以数据装载失败。</p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>我没有在layui官方API中找到相关组件加载完毕的回调方法,所以这里改为HTML同步数据填充,让layui加载完成后直接显示HTML的内容即可。</p><p><strong>原因是数据装载的时候,layui相关组件没有加载完毕造成装载数据失败! 后改为使用thymeleaf标签实现html的同步加载</strong></p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final String PAGE_PREFIX = &quot;product/&quot;; // 页面前缀</span><br><span class="line"></span><br><span class="line">@RequestMapping(value = &quot;inputPage&quot;)</span><br><span class="line">public String inputPage(String id, ModelMap modelMap)&#123;</span><br><span class="line">String tempId = &quot;none&quot;;</span><br><span class="line">if(StringUtils.isNotBlank(id)) &#123; // 修改</span><br><span class="line">ParamsMap productInfo = this.findProductInfo(id); // 查询需要修改的实体信息</span><br><span class="line">modelMap.put(&quot;productInfo&quot;, productInfo);</span><br><span class="line">tempId = id;</span><br><span class="line">&#125; else &#123; // 新增</span><br><span class="line">ParamsMap entity = initEntity();</span><br><span class="line">modelMap.put(&quot;productInfo&quot;, entity);</span><br><span class="line">&#125;</span><br><span class="line">return PAGE_PREFIX + &quot;input&quot;;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 初始化实体(用于新增)</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private ParamsMap initEntity()&#123;</span><br><span class="line">String json = &quot;JSON对象字符串&quot;;</span><br><span class="line">return new ParamsMap(json);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;layui-form-item&quot; pane=&quot;&quot;&gt;</span><br><span class="line">&lt;label class=&quot;layui-form-label&quot;&gt;预付款&lt;/label&gt;</span><br><span class="line">&lt;div class=&quot;layui-input-block&quot;&gt;</span><br><span class="line">&lt;input th:checked=&quot;$&#123;productInfo.is_advance==0&#125;&quot; lay-filter=&quot;is_advance&quot; type=&quot;radio&quot; name=&quot;is_advance&quot; value=&quot;0&quot; title=&quot;全款&quot;&gt;</span><br><span class="line">&lt;input th:checked=&quot;$&#123;productInfo.is_advance==1&#125;&quot; lay-filter=&quot;is_advance&quot; type=&quot;radio&quot; name=&quot;is_advance&quot; value=&quot;1&quot; title=&quot;支持预付款&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;layui-form-item&quot;&gt;</span><br><span class="line">&lt;label class=&quot;layui-form-label&quot;&gt;编辑内容&lt;/label&gt;</span><br><span class="line">&lt;div class=&quot;layui-input-inline&quot; style=&quot;padding-left: 20px;&quot;&gt;</span><br><span class="line">&lt;!-- 百度编辑器 --&gt;</span><br><span class="line">&lt;script id=&quot;editor&quot; th:utext=&quot;$&#123;productInfo.product_content&#125;&quot; type=&quot;text/plain&quot; style=&quot;width:500px;height:600px;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt;</span><br><span class="line">    var productInfo = [[$&#123;productInfo&#125;]]; // 可以让相关JS操作该对象</span><br><span class="line">    $().ready( function() &#123;</span><br><span class="line">        if(productInfo)&#123;</span><br><span class="line">            console.log(&quot;productInfo:&quot;,productInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;后台编辑页面的数据回显,时好时坏!（多发生于单选框）&lt;/p&gt;
&lt;p&gt;尝试使用setTimeout进行延时填充数据,效果还是时
      
    
    </summary>
    
    
      <category term="layui" scheme="https://blog.smilexin.cn/tags/layui/"/>
    
  </entry>
  
  <entry>
    <title>thymeleaf 常用标签</title>
    <link href="https://blog.smilexin.cn/2018/08/16/thymeleaf%20%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE.html"/>
    <id>https://blog.smilexin.cn/2018/08/16/thymeleaf 常用标签.html</id>
    <published>2018-08-15T16:00:00.000Z</published>
    <updated>2021-04-30T02:44:33.318Z</updated>
    
    <content type="html"><![CDATA[<p>记录自己常用的thymeleaf标签</p><h1 id="th-value"><a href="#th-value" class="headerlink" title="th:value"></a>th:value</h1><p>属性赋值,常用于表单回显<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input th:value=&quot;$&#123;user.name&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure></p><h1 id="th-checked"><a href="#th-checked" class="headerlink" title="th:checked"></a>th:checked</h1><p>选中为true,未选中为false,用于数据回显。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;layui-form-item&quot; pane=&quot;&quot;&gt;</span><br><span class="line">&lt;label class=&quot;layui-form-label&quot;&gt;议价规则&lt;/label&gt;</span><br><span class="line">&lt;div class=&quot;layui-input-block&quot;&gt;</span><br><span class="line">&lt;input th:checked=&quot;$&#123;productInfo.is_bargain==0&#125;&quot; lay-filter=&quot;is_bargain&quot; type=&quot;radio&quot; name=&quot;is_bargain&quot; value=&quot;0&quot; title=&quot;不支持议价&quot;&gt;</span><br><span class="line">&lt;input th:checked=&quot;$&#123;productInfo.is_bargain==1&#125;&quot; lay-filter=&quot;is_bargain&quot; type=&quot;radio&quot; name=&quot;is_bargain&quot; value=&quot;1&quot; title=&quot;支持议价&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h1 id="th-selected"><a href="#th-selected" class="headerlink" title="th:selected"></a>th:selected</h1><p>给页面select下拉框赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;layui-inline&quot;&gt;</span><br><span class="line">&lt;label class=&quot;layui-form-label&quot;&gt;商品单位&lt;/label&gt;</span><br><span class="line">&lt;div class=&quot;layui-input-block&quot;&gt;</span><br><span class="line">&lt;select id=&quot;product_unit&quot; name=&quot;product_unit&quot; lay-filter=&quot;product_unit&quot;&gt;</span><br><span class="line">&lt;option th:selected=&quot;$&#123;productInfo.product_unit==&apos;吨&apos;&#125;&quot; value=&quot;吨&quot; &gt;吨&lt;/option&gt;</span><br><span class="line">&lt;option th:selected=&quot;$&#123;productInfo.product_unit==&apos;千克&apos;&#125;&quot; value=&quot;千克&quot; &gt;千克&lt;/option&gt;</span><br><span class="line">&lt;option th:selected=&quot;$&#123;productInfo.product_unit==&apos;斤&apos;&#125;&quot; value=&quot;斤&quot; &gt;斤&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h1 id="th-utext"><a href="#th-utext" class="headerlink" title="th:utext"></a>th:utext</h1><p>支持html的文本替换,可用于百度编辑器ueditor的数据回显<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p th:utext=&quot;$&#123;htmlcontent&#125;&quot;&gt;conten&lt;/p&gt;</span><br><span class="line">&lt;script id=&quot;editor&quot; th:utext=&quot;$&#123;productInfo.product_content&#125;&quot; type=&quot;text/plain&quot; style=&quot;width:500px;height:600px;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h1 id="th-inline"><a href="#th-inline" class="headerlink" title="th:inline"></a>th:inline</h1><p>定义js脚本可以使用变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt;</span><br><span class="line">    var productInfo = [[$&#123;productInfo&#125;]]; // productInfo 为后台传递过来的对象参数</span><br><span class="line">    $().ready( function() &#123;</span><br><span class="line">        if(productInfo)&#123;</span><br><span class="line">            console.log(&quot;productInfo:&quot;,productInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h1 id="th-if"><a href="#th-if" class="headerlink" title="th:if"></a>th:if</h1><p>判断条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a th:if=&quot;$&#123;userId == collect.userId&#125;&quot; &gt;</span><br></pre></td></tr></table></figure></p><h1 id="th-unless"><a href="#th-unless" class="headerlink" title="th:unless"></a>th:unless</h1><p>和th:if判断相反<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a th:href=&quot;@&#123;/login&#125;&quot; th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录自己常用的thymeleaf标签&lt;/p&gt;
&lt;h1 id=&quot;th-value&quot;&gt;&lt;a href=&quot;#th-value&quot; class=&quot;headerlink&quot; title=&quot;th:value&quot;&gt;&lt;/a&gt;th:value&lt;/h1&gt;&lt;p&gt;属性赋值,常用于表单回显&lt;br&gt;&lt;fig
      
    
    </summary>
    
    
      <category term="thymeleaf" scheme="https://blog.smilexin.cn/tags/thymeleaf/"/>
    
  </entry>
  
</feed>
